---
layout: page
title: API Documentation
nav_label: api
---

<div class="row no-gutters">
    <div id="doc-col" class="col-md-8">
      {% include versions.html %}

      <h3 id="introduction">Introduction</h3>
      <p>Welcome to the Typesense API documentation. This documentation itself is open source.
        Please leave your feedback as issues on the
        <a href="https://github.com/typesense/typesense-website/issues">GitHub repo</a> or send us a pull-request
        to contribute edits.</p>

      <p><mark>To learn how to install and run Typesense, see our <a href="/guide">getting started guide</a> instead.</mark></p>

      <h3 id="api-clients">API clients</h3>

      <p>At the moment, we have API clients for Javascript, PHP, Python, and Ruby. </p>
      <p>We recommend that you use our API client library if it is available for your language.</p>

      {% code_block install %}
        ```javascript
          // Node.js
          npm install typesense

          // Browser
          <script src="dist/typesense.min.js"></script>
        ```

        ```php
          composer require typesense/typesense-php
        ```

        ```python
           pip install typesense
        ```

        ```ruby
           gem install typesense
        ```
      {% endcode_block %}

      <p>If you're using our Javascript client to access Typesense directly from the browser, be sure to start the
        Typesense server with the <code>--enable-cors</code> flag. </p>

      <h3 id="authentication">Authentication</h3>

      {% code_block authenticate %}
      ```javascript
        /*
         *  Our Javascript client library works on both the server and the browser.
         *  When using the library on the browser, please be sure to use the
         *  search-only API Key rather than the master API key since the latter
         *  has write access to Typesense and you don't want to expose that.
         */
        let client = new Typesense.Client({
          'nodes': [{
            'host': 'localhost',
            'port': '8108',
            'protocol': 'http',
          }],

          'apiKey': '<API_KEY>',
          'connectionTimeoutSeconds': 2
        })
      ```

      ```php
        use Typesense\Client;

        $client = new Client(
          [
            'nodes'        => [
              [
                'host'     => 'localhost',
                'port'     => '8108',
                'protocol' => 'http',
              ],
            ],
            'api_key'      => '<API_KEY>',
            'connection_timeout_seconds' => 2,
          ]
        );
        ```

      ```python
        import typesense

        client = typesense.Client({
          'nodes': [{
            'host': 'localhost',
            'port': '8108',
            'protocol': 'http',
          }],

          'api_key': '<API_KEY>',
          'connection_timeout_seconds': 2
        })
      ```

      ```ruby
        require 'typesense'

        client = Typesense::Client.new(
          nodes: [
            {
              host:     'localhost',
              port:     8108,
              protocol: 'http'
            }
          ],

          api_key:  '<API_KEY>',
          connection_timeout_seconds: 2
        )
      ```

      ```shell
          # API authentication is done via the `X-TYPESENSE-API-KEY` HTTP header.
          curl -H "X-TYPESENSE-API-KEY: <API_KEY>" "http://localhost:8108/collections"
      ```
      {% endcode_block %}

      <h3 id="usage">Usage</h3>

      <p>In Typesense, a group of related documents is called a <code>collection</code>. A <code>collection</code> is roughly
        equivalent to a table in a relational database.
      </p>

      <h4 id="create-collection">Create a collection</h4>

      <p>When a <code>collection</code> is created, we give it a name and describe the fields that will be indexed
        from the documents that are added to the <code>collection</code>.</p>

      <p>
        Your documents can contain other fields not mentioned in the collection's schema - they will be stored but
        not indexed.
      </p>

      {% code_block create-collection %}

      ```javascript
        let schema = {
          'name': 'companies',
          'num_documents': 0,
          'fields': [
            {
              'name': 'company_name',
              'type': 'string',
              'facet': false
            },
            {
              'name': 'num_employees',
              'type': 'int32',
              'facet': false
            },
            {
              'name': 'country',
              'type': 'string',
              'facet': true
            }
          ],
          'default_sorting_field': 'num_employees'
        }

        client.collections().create(schema)
      ```

      ```php
        $schema = [
          'name'      => 'companies',
          'fields'    => [
            [
              'name'  => 'company_name',
              'type'  => 'string'
            ],
            [
              'name'  => 'num_employees',
              'type'  => 'int32'
            ],
            [
              'name'  => 'country',
              'type'  => 'string',
              'facet' => true
            ]
          ],
          'default_sorting_field' => 'num_employees'
        ]

        $client->collections->create($schema)
      ```

      ```python
        schema = {
          'name': 'companies',
          'fields': [
            {
              'name'  :  'company_name',
              'type'  :  'string'
            },
            {
              'name'  :  'num_employees',
              'type'  :  'int32'
            },
            {
              'name'  :  'country',
              'type'  :  'string',
              'facet' :  True
            }
          ],
          'default_sorting_field': 'num_employees'
        }

        client.collections.create(schema)
      ```

      ```ruby
        schema = {
          'name'      => 'companies',
          'fields'    => [
            {
              'name'  => 'company_name',
              'type'  => 'string'
            },
            {
              'name'  => 'num_employees',
              'type'  => 'int32'
            },
            {
              'name'  => 'country',
              'type'  => 'string',
              'facet' => true
            }
          ],
          'default_sorting_field' => 'num_employees'
        }

        client.collections.create(schema)
      ```

      ```shell
        curl "http://localhost:8108/collections" -X POST -H "Content-Type: application/json" \
               -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
                 "name": "companies",
                 "fields": [
                   {"name": "company_name", "type": "string" },
                   {"name": "num_employees", "type": "int32" },
                   {"name": "country", "type": "string", "facet": true }
                 ],
                 "default_sorting_field": "num_employees"
               }'
      ```
      {% endcode_block %}


      <h5>Sample response</h5>

      {% code_block create-collection-response %}
      ```json
        {
          "name": "companies",
          "num_documents": 0,
          "fields": [
            {"name": "company_name", "type": "string" },
            {"name": "num_employees", "type": "int32" },
            {"name": "country", "type": "string", "facet": true }
          ],
          "default_sorting_field": "num_employees"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>POST ${TYPESENSE_HOST}/collections</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>name</td>
          <td>yes</td>
          <td>Name of the collection you wish to create.</td>
        </tr>
        <tr>
          <td>fields</td>
          <td>yes</td>
          <td>
            <p>A list of fields that you wish to index for querying, filtering and faceting. For each field, you
            have to specify the <code>name</code> and <code>type</code>.</p>

            <p><strong>Declaring a field as optional</strong></p>
            <p>A field can be declared as optional by setting <code>"optional": true</code>.</p>

            <p><strong>Declaring a field as a facet</strong></p>

            <p>A field can be declared as a facetable field by setting <code>"facet": true</code>.</p>
            <p>Faceted fields are indexed <strong>verbatim</strong> without any tokenization or preprocessing.
              For example, if you are building a product search, <code>color</code> and <code>brand</code> could be
              defined as facet fields.</p>
          </td>
        </tr>
        <tr>
          <td>default_sorting_field</td>
          <td>yes</td>
          <td>
            <p>The name of an <code>int32</code> / <code>float</code> field that determines the order in which
            the search results are ranked when a <code>sort_by</code> clause is not provided during searching.
              This field must indicate some kind of popularity. For example, in a product search
              application, you could define <code>num_reviews</code> field as the <code>default_sorting_field</code>.
            </p>

            <p>Additionally, when a word in a search query matches multiple possible words (either because of a typo or
              during a prefix search), this parameter is used to rank such equally matching tokens.
              For e.g. both "john" and "joan" are 1-typo away from "jofn". Similarly, in a
              prefix search, both "apple" and "apply" would match the prefix "app".</p>
          </td>
        </tr>
      </table>

      <h5>Supported search field types</h5>

      <p>Typesense allows you to index the following types of fields:</p>

      <table class="table table-striped">
        <tr><td><code>string</code></td></tr>
        <tr><td><code>int32</code></td></tr>
        <tr><td><code>int64</code></td></tr>
        <tr><td><code>float</code></td></tr>
        <tr><td><code>bool</code></td></tr>
      </table>

      <p>You can define an array or multi-valued field by suffixing a <code>[]</code> at the end:</p>

      <table class="table table-striped">
        <tr><td><code>string[]</code></td></tr>
        <tr><td><code>int32[]</code></td></tr>
        <tr><td><code>int64[]</code></td></tr>
        <tr><td><code>float[]</code></td></tr>
        <tr><td><code>bool[]</code></td></tr>
      </table>


      <h4 id="index-document">Index a document</h4>

      <p>A document to be indexed in a given collection must conform to the schema of the collection.</p>

      <p>
        If the document contains an <code>id</code> field of type <code>string</code>, Typesense would use that
        field as the identifier for the document. Otherwise, Typesense would assign an identifier of its choice to
        the document. Note that the <code>id</code> should not include spaces or any other characters that require
        <a href='https://www.w3schools.com/tags/ref_urlencode.asp'>encoding in urls</a>.
      </p>

      {% code_block index-document %}

        ```javascript
          let document = {
            'id': '124',
            'company_name': 'Stark Industries',
            'num_employees': 5215,
            'country': 'USA'
          }

          client.collections('companies').documents().create(document)
        ```

        ```php
        $document = [
          'id'            => '124',
          'company_name'  => 'Stark Industries',
          'num_employees' => 5215,
          'country'       => 'USA'
        ]

        $client->collections['companies']->documents->create($document)
        ```

        ```python
        document = {
          'id': '124',
          'company_name': 'Stark Industries',
          'num_employees': 5215,
          'country': 'USA'
        }

        client.collections['companies'].documents.create(document)
        ```

        ```ruby
        document = {
          'id'            => '124',
          'company_name'  => 'Stark Industries',
          'num_employees' => 5215,
          'country'       => 'USA'
        }

        client.collections['companies'].documents.create(document)
        ```

        ```shell
        curl "http://localhost:8108/collections/companies/documents" -X POST \
                -H "Content-Type: application/json" \
                -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
                -d '{
                  "id": "124",
                  "company_name": "Stark Industries",
                  "num_employees": 5215,
                  "country": "USA"
                }'
        ```
      {% endcode_block %}

      <h5>Upserting a document</h5>

      <p>You can also upsert a document.</p>

      {% code_block upsert-document %}

        ```javascript
          let document = {
            'id': '124',
            'company_name': 'Stark Industries',
            'num_employees': 5215,
            'country': 'USA'
          }

          client.collections('companies').documents().upsert(document)
        ```

        ```php
        $document = [
          'id'            => '124',
          'company_name'  => 'Stark Industries',
          'num_employees' => 5215,
          'country'       => 'USA'
        ]

        $client->collections['companies']->documents->upsert($document)
        ```

        ```python
        document = {
          'id': '124',
          'company_name': 'Stark Industries',
          'num_employees': 5215,
          'country': 'USA'
        }

        client.collections['companies'].documents.upsert(document)
        ```

        ```ruby
        document = {
          'id'            => '124',
          'company_name'  => 'Stark Industries',
          'num_employees' => 5215,
          'country'       => 'USA'
        }

        client.collections['companies'].documents.upsert(document)
        ```

        ```shell
        curl "http://localhost:8108/collections/companies/documents?action=upsert" -X POST \
                -H "Content-Type: application/json" \
                -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
                -d '{
                  "id": "124",
                  "company_name": "Stark Industries",
                  "num_employees": 5215,
                  "country": "USA"
                }'
        ```
      {% endcode_block %}

      <p>To index multiple documents at the same time, in a batch/bulk operation,
        see <a href="#import-documents">importing documents</a>.</p>

      <h5>Sample Response</h5>

      {% code_block index-document-response %}
      ```json
      {
        "id": "124",
        "company_name": "Stark Industries",
        "num_employees": 5215,
        "country": "USA"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>POST ${TYPESENSE_HOST}/collections/:collection/documents</code></p>

      <h4 id="search-collection">Search a collection</h4>

      <p>In Typesense, a search consists of a query against one or more text fields and a list of filters against numerical or
        facet fields. You can also sort and facet your results.</p>

      {% code_block search-collection %}
      ```javascript
        let searchParameters = {
          'q'         : 'stark',
          'query_by'  : 'company_name',
          'filter_by' : 'num_employees:>100',
          'sort_by'   : 'num_employees:desc'
        }

        client.collections('companies').documents().search(searchParameters)
      ```

      ```php
        $searchParameters = [
          'q'         => 'stark',
          'query_by'  => 'company_name',
          'filter_by' => 'num_employees:>100',
          'sort_by'   => 'num_employees:desc'
        ]

        $client->collections['companies']->documents->search($searchParameters)
      ```

      ```python
        search_parameters = {
          'q'         : 'stark',
          'query_by'  : 'company_name',
          'filter_by' : 'num_employees:>100',
          'sort_by'   : 'num_employees:desc'
        }

        client.collections['companies'].documents.search(search_parameters)
      ```

      ```ruby
        search_parameters = {
          'q'         => 'stark',
          'query_by'  => 'company_name',
          'filter_by' => 'num_employees:>100',
          'sort_by'   => 'num_employees:desc'
        }

        client.collections['companies'].documents.search(search_parameters)
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
        "http://localhost:8108/collections/companies/documents/search\
        ?q=stark&query_by=company_name&filter_by=num_employees:>100\
        &sort_by=num_employees:desc"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block search-collection-response %}
      ```json
        {
          "facet_counts": [],
          "found": 1,
          "out_of": 1,
          "page": 1,
          "request_params": { "q" : "" },
          "search_time_ms": 1,
          "hits": [
            {
              "highlights": [
                {
                  "field": "company_name",
                  "snippet": "<mark>Stark</mark> Industries",
                  "matched_tokens": ["Stark"]
                }
              ],
              "document": {
                "id": "124",
                "company_name": "Stark Industries",
                "num_employees": 5215,
                "country": "USA"
              }
            }
          ]
        }
      ```
      {% endcode_block %}

      <p>When a <code>string[]</code> field is queried, the <code>highlights</code> structure would include the
        corresponding matching array indices of the snippets. For e.g:</p>

      {% code_block highlights-arrray-response %}
      ```json
        {
              ...
              "highlights": [
                {
                  "field": "addresses",
                  "indices": [0,2],
                  "snippets": [
                    "10880 <mark>Malibu</mark> Point, <mark>Malibu,</mark> CA 90265",
                    "10000 <mark>Malibu</mark> Point, <mark>Malibu,</mark> CA 90265"
                  ],
                  "matched_tokens": [
                    ["Malibu", "Malibu"],
                    ["Malibu", "Malibu"]
                  ]
                }
              ],
              ...
        }
      ```
      {% endcode_block %}

      <h5>Group by</h5>

      <p>You can aggregate search results into groups or buckets by specify one or more <code>group_by</code> fields.</p>

      <p>Grouping hits this way is useful in:</p>

      <ul>
        <li><strong>Deduplication</strong>: By using one or more <code>group_by</code> fields, you can
          consolidate items and remove duplicates in the search results. For example, if there are multiple
          shoes of the same size, by doing a <code>group_by=size&group_limit=1</code>, you ensure that only a
          single shoe of each size is returned in the search results.</li>
        <li><strong>Correcting skew</strong>: When your results are dominated by documents of a particular
          type, you can use <code>group_by</code> and <code>group_limit</code> to correct that skew.
          For example, if your search results for a query contains way too many documents of the same <code>brand</code>,
          you can do a <code>group_by=brand&group_limit=3</code> to ensure that only the top 3 results of each brand
          is returned in the search results.</li>
      </ul>

      <p><mark><strong>NOTE:</strong> To group on a particular field, it must be a faceted field.</mark></p>

      <p>Grouping returns the hits in a nested structure, that's different from the plain JSON response format we saw
        earlier. Let's repeat the query we made earlier with a <code>group_by</code> parameter:</p>

      {% code_block search-group-collection %}

      ```javascript
      let searchParameters = {
        'q'            : 'stark',
        'query_by'     : 'company_name',
        'filter_by'    : 'num_employees:>100',
        'sort_by'      : 'num_employees:desc',
        'group_by'     : 'country',
        'group_limit'  : '1'
      }

      client.collections('companies').documents().search(searchParameters)
      ```

      ```php
      $searchParameters = [
        'q'           => 'stark',
        'query_by'    => 'company_name',
        'filter_by'   => 'num_employees:>100',
        'sort_by'     => 'num_employees:desc',
        'group_by'    => 'country',
        'group_limit' => '1'
      ]

      $client->collections['companies']->documents->search($searchParameters)
      ```

      ```python
      search_parameters = {
        'q'           : 'stark',
        'query_by'    : 'company_name',
        'filter_by'   : 'num_employees:>100',
        'sort_by'     : 'num_employees:desc',
        'group_by'    : 'country',
        'group_limit' : '1'
      }

      client.collections['companies'].documents.search(search_parameters)
      ```

      ```ruby
      search_parameters = {
        'q'           => 'stark',
        'query_by'    => 'company_name',
        'filter_by'   => 'num_employees:>100',
        'sort_by'     => 'num_employees:desc',
        'group_by'    => 'country',
        'group_limit' => '1'
      }

      client.collections['companies'].documents.search(search_parameters)
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
      "http://localhost:8108/collections/companies/documents/search\
      ?q=stark&query_by=company_name&filter_by=num_employees:>100\
      &sort_by=num_employees:desc&group_by=country&group_limit=1"
      ```
      {% endcode_block %}

      {% code_block search-group-by-collection-response %}
      ```json
      {
        "facet_counts": [],
        "found": 1,
        "out_of": 1,
        "page": 1,
        "request_params": { "q" : "" },
        "search_time_ms": 1,
        "grouped_hits": [
          {
            "group_key": ["USA"],
            "hits": [
              {
                "highlights": [
                  {
                    "field": "company_name",
                    "snippet": "<mark>Stark</mark> Industries"
                  }
                ],
                "document": {
                  "id": "124",
                  "company_name": "Stark Industries",
                  "num_employees": 5215,
                  "country": "USA"
                }
              }
            ]
          }
        ]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/documents/search</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>q</td>
          <td>yes</td>
          <td>
            <p>The query text to search for in the collection.</p>
            <p>
                Use <code>*</code> as the search string to return all documents. This is typically useful when used in
                conjunction with <code>filter_by</code>.</p>
                <p>For example, to return all documents that match a filter, use: <br/>
                <code>q=*&filter_by=num_employees:10</code> </p>
          </td>
        </tr>
        <tr>
          <td>query_by</td>
          <td>yes</td>
          <td>
            <p>One or more <code>string</code> / <code>string[]</code> fields that should be queried against.
              Separate multiple fields with a comma: <code>company_name, country</code></p>

            <p>The order of the fields is important: a record that matches on a field earlier in the list is
              considered more relevant than a record matched on a field later in the list.
              So, in the example above, documents that match on the <code>company_name</code> field are ranked above
              documents matched on the <code>country</code> field.</p></td>
        </tr>
        <tr>
          <td>query_by_weights</td>
          <td>no</td>
          <td>
            <p>The relative weight to give each <code>query_by</code> field when ranking results.
              This can be used to boost fields in priority, when looking for matches.
            </p>

            <p>Separate each weight with a comma, in the same order as the <code>query_by</code> fields.
              For eg: <code>query_by_weights: 1,1,2</code> with <code>query_by: field_a,field_b,field_c</code> will give equal weightage to <code>field_a</code> and <code>field_b</code>, and will give twice the weightage to <code>field_c</code> comparatively.
            </p>
          </td>
        </tr>
        <tr>
          <td>prefix</td>
          <td>no</td>
          <td><p>Boolean field to indicate that the last word in the query should be treated as a prefix, and not as a whole
            word. This is necessary for building autocomplete and instant search interfaces.</p>
            <p>Default: <code>true</code></p>
          </td>
        </tr>
        <tr>
          <td>filter_by</td>
          <td>no</td>
          <td><p>Filter conditions for refining your search results.</p>
              <p>A field can be matched against one or more values.</p>
              <p><code>country: USA</code> <br />
                 <code>country: [USA, UK]</code>
              </p>

              <ul>
                <li>
                  To match a string field exactly, you have to mark the field as a facet and use the <code>:=</code> operator.<br>
                  For eg: <code>category:=Shoe</code> will match documents from the
                  category <code>shoes</code> and <i>not</i> from a category like
                  <code>shoe rack</code>.
                  You can also filter using multiple values: <code>category:= [Shoe, Sneaker]</code>.
                </li>
                <li>
                  Get numeric values between a min and max value, using the range operator <code>[min..max]</code>
                  <br>
                  For eg: <code>num_employees:[10..100]</code>
                </li>
                <li>
                  Separate multiple conditions with the <code>&&</code> operator.
                  <br>
                  For eg: <code>num_employees:>100 && country: [USA, UK]</code>
                </li>
              </ul>

              <p>More examples:</p>
              <p><code>num_employees:10</code> <br />
                 <code>num_employees:<=10</code>
              </p>

          </td>
        </tr>
        <tr>
          <td>sort_by</td>
          <td>no</td>
          <td>
            <p>A list of numerical fields and their corresponding sort orders that will be used for ordering your results.
            Separate multiple fields with a comma. Up to 3 sort fields can be specified.</p>
            <p>E.g. <code>num_employees:desc,year_started:asc</code></p>

            <p>The text similarity score is exposed as a special <code>_text_match</code> field that you can use
            in the list of sorting fields.</p>

            <p>If one or two sorting fields are specified, <code>_text_match</code> is used for
              tie breaking, as the last sorting field.</p>

            <p>Default:</p>

            <p>If no <code>sort_by</code> parameter is specified, results are sorted by:
              <code>_text_match:desc,default_sorting_field:desc</code>.</p>
          </td>
        </tr>
        <tr>
          <td>facet_by</td>
          <td>no</td>
          <td><p>A list of fields that will be used for faceting your results on. Separate multiple fields with a comma.</p></td>
        </tr>
        <tr>
          <td>max_facet_values</td>
          <td>no</td>
          <td><p>Maximum number of facet values to be returned.</p></td>
        </tr>
        <tr>
          <td>facet_query</td>
          <td>no</td>
          <td><p>Facet values that are returned can now be filtered via this parameter. The matching facet text is
            also highlighted. For example, when faceting by <code>category</code>, you can set
            <code>facet_query=category:shoe</code> to return only facet values that contain the prefix "shoe". </p>
          </td>
        </tr>
        <tr>
          <td>num_typos</td>
          <td>no</td>
          <td><p>Number of typographical errors (1 or 2) that would be tolerated.</p>

            <p><a href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">Damerauâ€“Levenshtein distance</a>
              is used to calculate the number of errors.</p>

            <p>Default: <code>2</code></p>
          </td>
        </tr>
        <tr>
          <td>page</td>
          <td>no</td>
          <td><p>Results from this specific page number would be fetched.</p></td>
        </tr>
        <tr>
          <td>per_page</td>
          <td>no</td>
          <td>
            <p>Number of results to fetch per page.</p>
            <p>Default: <code>10</code></p>
          </td>
        </tr>
        <tr>
          <td>group_by</td>
          <td>no</td>
          <td><p>You can aggregate search results into groups or buckets by specify one or more
              <code>group_by</code> fields. Separate multiple fields with a comma.</p>
              <p>NOTE: To group on a particular field, it must be a faceted field.</p>
              <p>E.g. <code>group_by=country,company_name</code></p>
          </td>
        </tr>
        <tr>
          <td>group_limit</td>
          <td>no</td>
          <td><p>Maximum number of hits to be returned for every group. If the <code>group_limit</code> is
              set as <code>K</code> then only the top K hits in each group are returned in the response.</p>
              <p>Default: <code>3</code></p>
          </td>
        </tr>
        <tr>
          <td>include_fields</td>
          <td>no</td>
          <td><p>Comma-separated list of fields from the document to include in the search result.</p></td>
        </tr>
        <tr>
          <td>exclude_fields</td>
          <td>no</td>
          <td><p>Comma-separated list of fields from the document to exclude in the search result.</p></td>
        </tr>
        <tr>
          <td>highlight_full_fields</td>
          <td>no</td>
          <td>
            <p>Comma separated list of fields which should be highlighted fully without snippeting.</p>
            <p>Default: all fields will be snippeted.</p>
          </td>
        </tr>
        <tr>
          <td>highlight_affix_num_tokens</td>
          <td>no</td>
          <td>
            <p>The number of tokens that should surround the highlighted text on <em>each side</em>.</p>
            <p>Default: <code>4</code></p>
          </td>
        </tr>
        <tr>
          <td>highlight_start_tag</td>
          <td>no</td>
          <td>
            <p>The start tag used for the highlighted snippets.</p>
            <p>Default: <code>&lt;mark&gt;</code></p>
          </td>
        </tr>
        <tr>
          <td>highlight_end_tag</td>
          <td>no</td>
          <td>
            <p>The end tag used for the highlighted snippets.</p>
            <p>Default: <code>&lt;/mark&gt;</code></p>
          </td>
        </tr>
        <tr>
          <td>snippet_threshold</td>
          <td>no</td>
          <td><p>Field values under this length will be fully highlighted, instead of showing a snippet of
              relevant portion.</p>
              <p>Default: <code>30</code></p>
          </td>
        </tr>
        <tr>
          <td>drop_tokens_threshold</td>
          <td>no</td>
          <td>
              <p>
                  If the number of results found for a specific query is less than this number, Typesense will attempt
                  to drop the tokens in the query until enough results are found. Tokens that have the least individual hits
                  are dropped first. Set <code>drop_tokens_threshold</code> to <code>0</code> to disable dropping of tokens.
              </p>
              <p>
                Default: <code>10</code>
              </p>
          </td>
        </tr>
        <tr>
          <td>typo_tokens_threshold</td>
          <td>no</td>
          <td>
            <p>
              If the number of results found for a specific query is less than this number, Typesense will attempt to
              look for tokens with more typos until enough results are found.
            </p>
            <p>
              Default: <code>100</code>
            </p>
          </td>
        </tr>
        <tr>
          <td>pinned_hits</td>
          <td>no</td>
          <td>
            <p>A list of records to unconditionally include in the search results at specific positions.</p>
            <p>An example use case would be to feature or promote certain items on the top of search results.</p>
            <p>A comma separated list of <code>record_id:hit_position</code>. Eg: to include a record with ID 123 at Position 1
              and another record with ID 456 at Position 5, you'd specify <code>123:1,456:5</code>.
            </p>
            <p>You could also use the Overrides feature to override search results based on rules.
              Overrides are applied first, followed by pinned_hits and finally hidden_hits.
            </p>
          </td>
        </tr>
        <tr>
          <td>hidden_hits</td>
          <td>no</td>
          <td>
            <p>A list of records to unconditionally hide from search results.</p>
            <p>A comma separated list of <code>record_id</code>s to hide. Eg: to hide records with IDs 123 and 456,
              you'd specify <code>123,456</code>.
            </p>
            <p>You could also use the Overrides feature to override search results based on rules.
              Overrides are applied first, followed by pinned_hits and finally hidden_hits.
            </p>
          </td>
        </tr>
        <tr>
          <td>limit_hits</td>
          <td>no</td>
          <td>
            <p>Maximum number of hits that can be fetched from the collection. Eg: <code>200</code></p>
            <p><code>page * per_page</code> should be less than this number for the search request to return results.</p>
            <p>Default: no limit</p>
            <p>You'd typically want to generate a scoped API key with this parameter embedded and use that API key to perform the search, so it's automatically applied and can't be changed at search time.</p>
          </td>
        </tr>


      </table>

      <h4 id="multi-search" class="mt-5">Federated / Multi Search</h4>

      <p>
        You can send multiple search requests in a single HTTP request, using the Multi-Search feature. This is especially useful to avoid round-trip network latencies incurred otherwise if each of these requests are sent in separate HTTP requests.
      </p>

      <p>You can also use this feature to do a <strong>federated search</strong> across multiple collections in a single HTTP request.</p>

      {% code_block multi-search %}
      ```javascript
        let searchRequests = {
          'searches': [
            {
              'collection': 'products',
              'q': 'shoe',
              'filter_by': 'price:=[50..120]'
            },
            {
              'collection': 'brands',
              'q': 'Nike'
            }
          ]
        }

        // Search parameters that are common to all searches go here
        let commonSearchParams =  {
            'query_by': 'name',
        }

        client.multiSearch.perform(searchRequests, commonSearchParams)
      ```

      ```php
        $searchRequests = [
          'searches' => [
            [
              'collection' => 'products',
              'q' => 'shoe',
              'filter_by' => 'price:=[50..120]'
            ],
            [
              'collection' => 'brands',
              'q' => 'Nike'
            ]
          ]
        ]

        // Search parameters that are common to all searches go here
        $commonSearchParams =  [
            'query_by' => 'name',
        ]

        $client->multiSearch->perform($searchRequests, $commonSearchParams)
      ```

      ```python
        search_requests = {
          'searches': [
            {
              'collection': 'products',
              'q': 'shoe',
              'filter_by': 'price:=[50..120]'
            },
            {
              'collection': 'brands',
              'q': 'Nike'
            }
          ]
        }

        # Search parameters that are common to all searches go here
        common_search_params =  {
            'query_by': 'name',
        }

        client.multi_search.perform(search_requests, common_search_params)
      ```

      ```ruby
        search_requests = {
          'searches': [
            {
              'collection': 'products',
              'q': 'shoe',
              'filter_by': 'price:=[50..120]'
            },
            {
              'collection': 'brands',
              'q': 'Nike'
            }
          ]
        }

        # Search parameters that are common to all searches go here
        common_search_params =  {
            'query_by': 'name',
        }

        client.multi_search.perform(search_requests, common_search_params)
      ```

      ```shell
        curl "http://localhost:8108/multi_search?query_by=name" \
                -X POST \
                -H "Content-Type: application/json" \
                -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
                -d '{
                  "searches": [
                    {
                      "collection": "products",
                      "q": "shoe",
                      "filter_by": "price:=[50..120]"
                    },
                    {
                      "collection": "brands",
                      "q": "Nike"
                    }
                  ]
                }'
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block multi-search-response %}
      ```json
        {
          "results": [
            {
              "facet_counts": [],
              "found": 1,
              "hits": [
                {
                  "document": {
                    "name": "Blue shoe",
                    "brand": "Adidas",
                    "id": "126",
                    "price": 50
                  },
                  "highlights": [
                    {
                      "field": "name",
                      "matched_tokens": [
                        "shoe"
                      ],
                      "snippet": "Blue <mark>shoe</mark>"
                    }
                  ],
                  "text_match": 130816
                }
              ],
              "out_of": 10,
              "page": 1,
              "request_params": {
                "per_page": 10,
                "q": "shoe"
              },
              "search_time_ms": 1
            },
            {
              "facet_counts": [],
              "found": 1,
              "hits": [
                {
                  "document": {
                    "name": "Nike shoes",
                    "brand": "Nike",
                    "id": "391",
                    "price": 60
                  },
                  "highlights": [
                    {
                      "field": "name",
                      "matched_tokens": [
                        "Nike"
                      ],
                      "snippet": "<mark>Nike</mark>shoes"
                    }
                  ],
                  "text_match": 144112
                }
              ],
              "out_of": 5,
              "page": 1,
              "request_params": {
                "per_page": 10,
                "q": "Nike"
              },
              "search_time_ms": 1
            },
          ]
        }

      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>POST ${TYPESENSE_HOST}/multi_search</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>limit_multi_searches</td>
          <td>no</td>
          <td>
            <p>Max number of search requests that can be sent in a multi-search request. Eg: <code>20</code></p>
            <p>Default: no limit</p>
            <p>
              You'd typically want to generate a scoped API key with this parameter embedded
              and use that API key to perform the search, so it's automatically applied and can't be changed at search time.
            </p>
          </td>
        </tr>
      </table>

      <h4 id="retrieve-document">Retrieve a document</h4>

      Fetch an individual document from a collection by using its <code>id</code>.

      {% code_block retrieve-document %}
      ```javascript
        client.collections('companies').documents('124').retrieve()
      ```

      ```php
        $client->collections['companies']->documents['124']->retrieve()
      ```

      ```python
        client.collections['companies'].documents['124'].retrieve()
      ```

      ```ruby
        client.collections['companies'].documents['124'].retrieve
      ```

      ```shell
        $ curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X GET \
              "http://localhost:8108/collections/companies/documents/124"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block retrieve-document-response %}
      ```json
        {
          "id": "124",
          "company_name": "Stark Industries",
          "num_employees": 5215,
          "country": "USA"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/documents/:id</code></p>

      <h4 id="update-document">Update a document</h4>

      <p>Update an individual document from a collection by using its <code>id</code>.
      The update can be partial, as shown below:</p>

      {% code_block update-document %}

        ```javascript
          let document = {
            'company_name': 'Stark Industries',
            'num_employees': 5500
          }

          client.collections('companies').documents('124').update(document)
        ```

        ```php
        $document = [
          'company_name'  => 'Stark Industries',
          'num_employees' => 5500
        ]

        $client->collections['companies']->documents['124']->update($document)
        ```

        ```python
        document = {
          'company_name': 'Stark Industries',
          'num_employees': 5500
        }

        client.collections['companies'].documents['124'].update(document)
        ```

        ```ruby
        document = {
          'company_name'  => 'Stark Industries',
          'num_employees' => 5500
        }

        client.collections['companies'].documents['124'].update(document)
        ```

        ```shell
        curl "http://localhost:8108/collections/companies/documents/124" -X PATCH \
                -H "Content-Type: application/json" \
                -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
                -d '{
                  "company_name": "Stark Industries",
                  "num_employees": 5500
                }'
        ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block update-document-response %}
      ```json
        {
          "company_name": "Stark Industries",
          "num_employees": 5500
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>PATCH ${TYPESENSE_HOST}/collections/:collection/documents/:id</code></p>

      <h4 id="delete-document">Deleting documents</h4>

      <p>Delete an individual document from a collection by using its <code>id</code>.</p>

      {% code_block delete-document %}
      ```javascript
        client.collections('companies').documents('124').delete()
      ```

      ```php
        $client->collections['companies']->documents['124']->delete()
      ```

      ```python
        client.collections['companies'].documents['124'].delete()
      ```

      ```ruby
        client.collections['companies'].documents['124'].delete
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X DELETE \
            "http://localhost:8108/collections/companies/documents/124"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block delete-document-response %}
      ```json
        {
          "id": "124",
          "company_name": "Stark Industries",
          "num_employees": 5215,
          "country": "USA"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>DELETE ${TYPESENSE_HOST}/collections/:collection/documents/:id</code></p>

      <p>You can also delete a bunch of documents that match a specific filter condition:</p>

      {% code_block delete-documents %}
      ```javascript
      client.collections('companies').documents().delete({'filter_by': 'num_employees:>100'})
      ```

      ```php
      $client->collections['companies']->documents->delete(['filter_by' => 'num_employees:>100']));
      ```

      ```python
      client.collections['companies'].documents.delete_({'filter_by': 'num_employees:>100'})
      ```

      ```ruby
      client.collections['companies'].documents.delete(filter_by: 'num_employees:>100')
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X DELETE \
      "http://localhost:8108/collections/companies/documents?filter_by=num_employees:>=100&batch_size=100"
      ```
      {% endcode_block %}

      <p>Use the <code>batch_size</code> parameter to control the number of documents that should
        deleted at a time. A larger value will speed up deletions, but will impact performance of other
        operations running on the server.</p>

      <h5>Sample response</h5>

      {% code_block delete-document-response %}
      ```json
      {
        "num_deleted": 24
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>DELETE ${TYPESENSE_HOST}/collections/:collection/documents?filter_by=X&batch_size=N</code></p>

      <h4 id="retrieve-collection">Retrieve a collection</h4>

      <p>Retrieve the details of a collection, given its name.</p>

      {% code_block retrieve-collection %}
      ```javascript
        client.collections('companies').retrieve()
      ```

      ```php
        $client->collections['companies']->retrieve()
      ```

      ```python
        client.collections['companies'].retrieve()
      ```

      ```ruby
        client.collections['companies'].retrieve
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X GET
            "http://localhost:8108/collections/companies"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block retrieve-collection-response %}
      ```json
        {
          "name": "companies",
          "num_documents": 1250,
          "fields": [
            {"name": "company_name", "type": "string"},
            {"name": "num_employees", "type": "int32"},
            {"name": "country", "type": "string", "facet": true}
          ],
          "default_sorting_field": "num_employees"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection</code></p>

      <h4 id="export-documents">Export documents from a collection</h4>

      {% code_block export-documents %}
      ```javascript
        client.collections('companies').documents().export()
      ```

      ```php
        $client->collections['companies']->documents->export()
      ```

      ```python
        client.collections['companies'].documents.export()
      ```

      ```ruby
        client.collections['companies'].documents.export
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X GET
            "http://localhost:8108/collections/companies/documents/export"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block export-documents-response %}
        ```jsonlines
          {"id": "124", "company_name": "Stark Industries", "num_employees": 5215,\
          "country": "US"}
          {"id": "125", "company_name": "Future Technology", "num_employees": 1232,\
          "country": "UK"}
          {"id": "126", "company_name": "Random Corp.", "num_employees": 531,\
          "country": "AU"}
        ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/documents/export</code></p>

      <h4 id="import-documents">Import documents into a collection</h4>

      <p>The documents to be imported can be either an array of document objects or be formatted as a newline
        delimited JSON string (see <a href="https://jsonlines.org/">JSONL</a>).</p>

      <h5>Indexing multiple documents at the same time</h5>

      <p>You can index multiple documents via the import API.</p>

      {% code_block upsert-documents %}

        ```javascript
          let documents = [{
            'id': '124',
            'company_name': 'Stark Industries',
            'num_employees': 5215,
            'country': 'USA'
          }]

          client.collections('companies').documents().import(documents, {action: 'upsert'})
        ```

        ```php
        $documents = [[
          'id'            => '124',
          'company_name'  => 'Stark Industries',
          'num_employees' => 5215,
          'country'       => 'USA'
        ]]

        $client->collections['companies']->documents->import($documents, ['action' => 'upsert'])
        ```

        ```python
        documents = [{
          'id': '124',
          'company_name': 'Stark Industries',
          'num_employees': 5215,
          'country': 'USA'
        }]

        client.collections['companies'].documents.import_(documents, {'action': 'upsert'})
        ```

        ```ruby
        documents = [{
          'id'            => '124',
          'company_name'  => 'Stark Industries',
          'num_employees' => 5215,
          'country'       => 'USA'
        }]

        client.collections['companies'].documents.import(documents, action: 'upsert')
        ```
      {% endcode_block %}

      <p>The other allowed <code>action</code> modes are <code>create</code> and <code>update</code>.</p>

      <h5>Action modes</h5>

      <table class="table table-striped">
        <tr>
          <td>create (default)</td>
          <td>Creates a new document. Fails if a document with the same <code>id</code> already exists.</td>
        </tr>
        <tr>
          <td>upsert</td>
          <td>Creates a new document or updates an existing document if a document with the same
            <code>id</code> already exists.</td>
        </tr>
        <tr>
          <td>update</td>
          <td>Updates an existing document. Fails if a document with the given <code>id</code> does not exist.</td>
        </tr>
      </table>

      <h5>Importing a JSONL file</h5>

      <p>You can feed the output of a Typesense export operation directly as import to the import end-point since
        both use JSONL.</p>

      <p>Here's an example file:</p>

      {% code_block import-documents-sample-docs %}
      ```jsonl
      {"id": "1", "company_name": "Stark Industries", "num_employees": 5215, "country": "USA"}
      {"id": "2", "company_name": "Orbit Inc.", "num_employees": 256, "country": "UK"}
      ```
      {% endcode_block %}

      <p>You can import the above <code>documents.jsonl</code> file like this.</p>

      {% code_block import-documents %}

      ```javascript
         const documentsInJsonl = await fs.readFile("documents.jsonl");
         client.collections('companies').documents().import(documentsInJsonl, {action: 'create'});
      ```

      ```php
        $documentsInJsonl = file_get_contents('documents.jsonl');
        client.collections['companies'].documents.import($documentsInJsonl, ['action' => 'create'])
      ```

      ```python
        with open('documents.jsonl') as jsonl_file:
          client.collections['companies'].documents.import_jsonl(jsonl_file.read(), {'action': 'create'})
      ```

      ```ruby
        documents_jsonl = File.read('documents.jsonl')
        collections['companies'].documents.import(documents_jsonl, action: 'create')
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X POST --data-binary @documents.jsonl \
      "http://localhost:8108/collections/companies/documents/import?action=create"
      ```
      {% endcode_block %}

      <p>In the example above, we're importing the documents with the <code>action</code> flag
        set to <code>create</code>. This means that the documents will be inserted only if a document with the
        same <code>id</code> is not already found.</p>

      <p>As we have seen earlier, you can also use the <code>upsert</code> and <code>update</code> actions.
        If you don't provide an <code>action</code>, the default mode is <code>create</code>.</p>

      <h5>Configuring the batch size used for import</h5>

      <p>By default, Typesense ingests 40 documents at a time into Typesense. To increase this value, use the
      <code>batch_size</code> parameter. </p>

      {% code_block import-documents-batch-size %}

      ```javascript
         const documentsInJsonl = await fs.readFile("documents.jsonl");
         client.collections('companies').documents().import(documentsInJsonl, {batch_size: 100});
      ```

      ```php
        $documentsInJsonl = file_get_contents('documents.jsonl');
        client.collections['companies'].documents.import($documentsInJsonl, ['batch_size' => 100])
      ```

      ```python
        with open('documents.jsonl') as jsonl_file:
          client.collections['companies'].documents.import_jsonl(jsonl_file.read(), {'batch_size': 100})
      ```

      ```ruby
        documents_jsonl = File.read('documents.jsonl')
        collections['companies'].documents.import(documents_jsonl, batch_size: 100)
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X POST --data-binary @documents.jsonl \
      "http://localhost:8108/collections/companies/documents/import?batch_size=100"
      ```
      {% endcode_block %}

      <p><strong>NOTE:</strong> Larger batch sizes will consume larger transient memory during import.</p>

      <h5>Sample response</h5>

      {% code_block import-documents-response %}
      ```jsonlines
        {"success": true}
        {"success": true}
      ```
      {% endcode_block %}

      <p>Each line of the response indicates the result of each document present in the request body (in the same order).
        If the import of a single document fails, it does not affect the other documents.</p>

      <p>If there is a failure, the response line will include a corresponding error message and as well as the
        actual document content. For example, the second document had an import failure in the following response:</p>

      {% code_block import-documents-err-response %}
      ```json
        {"success": true}
        {"success": false, "error": "Bad JSON.", "document": "[bad doc"}
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>POST ${TYPESENSE_HOST}/collections/:collection/documents/import</code></p>

      <h4 id="list-collection">List all collections</h4>

      <p>Returns a summary of all your collections. The collections are returned sorted by creation date,
        with the most recent collections appearing first.</p>

      {% code_block list-collection %}

      ```javascript
        client.collections().retrieve()
      ```

      ```php
        $client->collections->retrieve()
      ```

      ```python
        client.collections.retrieve()
      ```

      ```ruby
        client.collections.retrieve
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" "http://localhost:8108/collections"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block list-collection-response %}
      ```json
      [
        {
          "num_documents": 1250,
          "name": "companies",
          "fields": [
            {"name": "company_name", "type": "string"},
            {"name": "num_employees", "type": "int32"},
            {"name": "country", "type": "string", "facet": true}
          ],
          "default_sorting_field": "num_employees"
        },
        {
          "num_documents": 1250,
          "name": "ceos",
          "fields": [
            {"name": "company_name", "type": "string"},
            {"name": "full_name", "type": "string"},
            {"name": "from_year", "type": "int32"}
          ],
          "default_sorting_field": "num_employees"
        }
      ]
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections</code></p>

      <h4 id="drop-collection">Drop a collection</h4>

      <p>Permanently drops a collection. This action cannot be undone. For large collections, this might have an impact on read
        latencies.</p>

      {% code_block drop-collection %}
      ```javascript
        client.collections('companies').delete()
      ```

      ```php
        $client->collections['companies']->delete()
      ```

      ```python
        client.collections['companies'].delete()
      ```

      ```ruby
        client.collections['companies'].delete
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X DELETE
            "http://localhost:8108/collections/companies"
      ```

      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block drop-collection-response %}
      ```json
      {
        "name": "companies",
        "num_documents": 1250,
        "fields": [
          {"name": "company_name", "type": "string"},
          {"name": "num_employees", "type": "int32"},
          {"name": "country", "type": "string", "facet": true}
        ],
        "default_sorting_field": "num_employees"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>DELETE ${TYPESENSE_HOST}/collections/:collection</code></p>

      <h3 id="api-keys">API Keys</h3>

      <p>Typesense allows you to create API Keys with fine-grain access control. You can restrict access on
      both a per-collection and per-action level.</p>

      <p><mark>We will be using the initial bootstrap key that you started Typesense with (via <code>--api-key</code>>)
        to create additional keys. It's <strong>strongly recommended</strong> that you don't use the bootstrap
        API key directly in your production applications. Instead you want to generate an appropriately-scoped key for the application at hand.</mark>
      </p>

      <h4 id="create-key">Create an API Key</h4>

      <p>Let's begin by creating an API key that allows you to do all operations, i.e. it's effectively an admin key and
        is equivalent to the key that you start Typesense with (via <code>--api-key</code>). </p>

      {% code_block create-admin-key %}
      ```javascript
      key = client.keys().create({
        'description': 'Admin key.',
        'actions': ['*'],
        'collections': ['*']
      })
      ```

      ```php
      $key = $client->keys->create([
        'description' => 'Admin key.',
        'actions' => ['*'],
        'collections' => ['*']
      ])
      ```

      ```python
      key = client.keys.create({
        "description": "Admin key.",
        "actions": ["*"],
        "collections": ["*"]
      })
      ```

      ```ruby
      key = client.keys.create({
        'description' => 'Admin key.',
        'actions' => ['*'],
        'collections' => ['*']
      })
      ```

      ```shell
      curl 'http://localhost:8108/keys' -X POST -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
      -H 'Content-Type: application/json' \
      -d '{"description":"Admin key.","actions": ["*"], "collections": ["*"]}'
      ```
      {% endcode_block %}

      <p>By setting both <code>actions</code> and <code>collections</code> to a wildcard <code>['*']</code> scope,
        we're able to create an admin key that gives you universal access. However, you should refrain from creating
      such widely scoped keys. </p>

      <p><mark><strong>NOTE: </strong>The generated key is only returned during creation. You want to store this
        key carefully in a secure place.</mark></p>

      <p>Let's now see how we can create a search-only key that allows you to limit the
      key's scope to only the search action, and also for only a specific collection.</p>

      {% code_block create-search-key %}
      ```javascript
      client.keys().create({
        'description': 'Admin key.',
        'actions': ['documents:search'],
        'collections': ['companies']
      })
      ```

      ```php
      $client->keys->create([
        'description' => 'Search-only companies key.',
        'actions' => ['documents:search'],
        'collections' => ['companies']
      ])
      ```

      ```python
      client.keys.create({
        "description": "Search-only companies key.",
        "actions": ["documents:search"],
        "collections": ["companies"]
      })
      ```

      ```ruby
      client.keys.create({
        'description' => 'Search-only companies key.',
        'actions' => ['documents:search'],
        'collections' => ['companies']
      })
      ```

      ```shell
      curl 'http://localhost:8108/keys' -X POST -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
      -H 'Content-Type: application/json' \
      -d '{"description":"Search-only companies key.","actions": ["documents:search"], "collections": ["companies"]}'
      ```
      {% endcode_block %}

      <p>By setting the <code>actions</code> scope to <code>["documents:search"]</code> and the <code>collections</code>
      scope to <code>["companies"]</code>, we can generate a key that is allowed to only conduct searches on the
      <code>companies</code> collection.</p>

      <h5>Sample response</h5>

      {% code_block api-key-creation-response %}
      ```json
      {
        "actions": [
          "*"
        ],
        "collections": [
          "*"
        ],
        "description": "Admin key.",
        "id": 1,
        "value": "k8pX5hD0793d8YQC5aD1aEPd7VleSuGP"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>POST ${TYPESENSE_HOST}/keys</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>actions</td>
          <td>yes</td>
          <td>List of allowed actions. See next table for possible values.</td>
        </tr>
        <tr>
          <td>collections</td>
          <td>yes</td>
          <td>List of collections that this key is scoped to. Supports regex. Eg: <code>coll.*</code> will match all collections that have "coll" in their name.</td>
        </tr>
        <tr>
          <td>description</td>
          <td>no</td>
          <td>Internal description to identify what the key is for</td>
        </tr>
        <tr>
          <td>expires_at</td>
          <td>no</td>
          <td><a href="https://www.epochconverter.com/" target="_blank">Unix timestamp</a> until which the key is valid.</td>
        </tr>
      </table>

      <h5>Sample actions</h5>

      <table class="table table-striped">
        <tr>
          <th>Action</th>
          <th>Description</th>
        </tr>
        <tr>
          <td><code>documents:search</code></td>
          <td>
            <p>Allows only search requests.</p>
          </td>
        </tr>
        <tr>
          <td><code>documents:get</code></td>
          <td>
            <p>Allows fetching a single document.</p>
          </td>
        </tr>
        <tr>
          <td><code>collections:delete</code></td>
          <td>
            <p>Allows a collection to be deleted.</p>
          </td>
        </tr>
        <tr>
          <td><code>collections:create</code></td>
          <td>
            <p>Allows a collection to be created.</p>
          </td>
        </tr>
        <tr>
          <td><code>collections:*</code></td>
          <td>
            <p>Allow all kinds of collection related operations.</p>
          </td>
        </tr>
        <tr>
          <td><code>*</code></td>
          <td>
            <p>Allows all operations.</p>
          </td>
        </tr>
      </table>

      <h4 id="retrieve-key">Retrieve an API Key</h4>

      <p>Retrieve (metadata about) a key.</p>

      {% code_block retrieve-api-key %}
      ```javascript
      key = client.keys(1).retrieve()
      ```

      ```php
      $key = $client->keys[1]->retrieve()
      ```

      ```python
      key = client.keys[1].retrieve()
      ```

      ```ruby
      key = client.keys[1].retrieve
      ```

      ```shell
      curl 'http://localhost:8108/keys/1' -X GET -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block api-key-retrieval-response %}
      ```json
      {
        "actions": [ "documents:search" ],
        "collections": [ "*" ],
        "description": "Search-only key.",
        "id": 1,
        "value_prefix": "vxpx"
      }
      ```
      {% endcode_block %}

      <p>Notice how only the key prefix is returned when you retrieve a key. Due to security reasons, only the
          create endpoint returns the full API key.</p>

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/keys/:id</code></p>

      <h4 id="list-keys">List all keys</h4>

      <p>Retrieve (metadata about) all keys.</p>

      {% code_block list-all-keys %}
      ```javascript
      client.keys().retrieve()
      ```

      ```php
      $client->keys->retrieve()
      ```

      ```python
      client.keys.retrieve()
      ```

      ```ruby
      client.keys.retrieve
      ```

      ```shell
      curl 'http://localhost:8108/keys' -X GET -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block all-api-keys-retrieval-response %}
      ```json
      {
        "keys": [
          {
            "actions": [
              "documents:search"
            ],
            "collections": [
              "users"
            ],
            "description": "Search-only key.",
            "id": 1,
            "value_prefix": "iKBT"
          },
          {
            "actions": [
              "documents:search"
            ],
            "collections": [
              "users"
            ],
            "description": "Search-only key.",
            "id": 2,
            "value_prefix": "wst8"
          }
        ]
      }
      ```
      {% endcode_block %}

      <p>Notice how only the key prefix is returned when you retrieve a key. Due to security reasons, only the
        create endpoint returns the full API key.</p>

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/keys</code></p>

      <h4 id="delete-key">Delete API Key</h4>

      <p>Delete an API key given its ID.</p>

      {% code_block delete-api-key %}
      ```javascript
      key = client.keys(1).delete()
      ```

      ```php
      $key = $client->keys[1]->delete()
      ```

      ```python
      key = client.keys[1].delete()
      ```

      ```ruby
      key = client.keys[1].delete
      ```

      ```shell
      curl 'http://localhost:8108/keys/1' -X DELETE -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block api-key-deletion-response %}
      ```json
      {
        "id": 1
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>DELETE ${TYPESENSE_HOST}/keys/:id</code></p>

      <h4 id="generate-scoped-search-key">Generate Scoped Search Key</h4>

      <p>
        You can generate scoped search API keys that have embedded search parameters in them. This is useful for example
        when you have multi-tenant data indexed in your Typesense instance, but only want your users to access their own subset of the data.
      </p>

      <p>To do this, you can embed a filter in a generated scoped search API key. When you use that key for search operations,
        those filters will get automatically applied and cannot be overriden.
      </p>

      <p>
        We can generate scoped search API keys without having to make any calls to the Typesense server. We use an API key
        that we previously generated with a search scope, create an HMAC digest of the parameters with this key and use that
        as the API key. Our client libraries handle this logic for you, but you can also generate scoped search API keys from the command line.
      </p>

      <p>
        <mark><strong>Note:</strong>
          Remember to never expose your main search key client-side, since exposing the main search key will allow anyone to query the entire data set
          without your embedded search parameters.
        </mark>
      </p>

      {% code_block generate-scoped-search-api-key %}
      ```javascript
      keyWithSearchPermissions = 'RN23GFr1s6jQ9kgSNg2O7fYcAUXU7127'
      client.keys().generateScopedSearchKey(keyWithSearchPermissions, {'filter_by': 'company_id:124', 'expires_at': 1611590465})
      ```

      ```php
      $keyWithSearchPermissions = 'RN23GFr1s6jQ9kgSNg2O7fYcAUXU7127'
      $client->keys()->generateScopedSearchKey($keyWithSearchPermissions, ['filter_by' => 'company_id:124', 'expires_at' => 1611590465])
      ```

      ```python
      key_with_search_permissions = 'RN23GFr1s6jQ9kgSNg2O7fYcAUXU7127'
      client.keys().generate_scoped_search_key(key_with_search_permissions, {"filter_by": "company_id:124", "expires_at": 1611590465})
      ```

      ```ruby
      key_with_search_permissions = 'RN23GFr1s6jQ9kgSNg2O7fYcAUXU7127'
      client.keys().generate_scoped_search_key(key_with_search_permissions, {'filter_by': 'company_id:124', 'expires_at': 1611590465})
      ```

      ```shell
      KEY_WITH_SEARCH_PERMISSIONS="RN23GFr1s6jQ9kgSNg2O7fYcAUXU7127"
      EMBEDDED_SEARCH_PARAMETERS_JSON='{"filter_by":"company_id:124","expires_at":1611590465}'

      digest=$(echo -n $EMBEDDED_SEARCH_PARAMETERS_JSON | openssl dgst -sha256 -hmac $KEY_WITH_SEARCH_PERMISSIONS -binary | base64)

      scoped_api_key=$(echo -n "${digest}${KEY_WITH_SEARCH_PERMISSIONS:0:4}${EMBEDDED_SEARCH_PARAMETERS_JSON}" | base64)

      echo $scoped_api_key
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block api-key-deletion-response %}
      ```json
      "SC9sT0hncHFwTHNFc3U3d3psRDZBUGNXQUViQUdDNmRHSmJFQnNnczJ4VT1STjIzeyJmaWx0ZXJfYnkiOiJjb21wYW55X2lkOjEyNCJ9"
      ```
      {% endcode_block %}

      <p>You can also set a custom <code>expires_at</code> for a scoped API key. The expiration for a scoped API key
        should be less than the expiration of the parent API key with which it is generated.</p>

      <h3 id="curation">Curation</h3>

      <p>While Typesense makes it really easy and intuitive to deliver great search results, sometimes you might
        want to promote certain documents over others. Or, you might want to exclude certain documents from a
        query's result set.</p>

      <p>Using overrides, you can include or exclude specific documents for a given query.</p>

      <h4 id="create-update-override">Create or update an override</h4>

      <p>In the following example, we are overriding the search results by placing the documents with ids <code>422</code>
        and <code>54</code> in the first and second positions respectively via the <code>includes</code> condition.
        Additionally, we're ensuring that the document with id <code>287</code> is not returned at all
        via the <code>excludes</code> condition. You need to specify only one of <code>exclude</code> or
        <code>include</code>.</p>

      <p>Note how we are applying these overrides to an <code>exact</code> match of the query <code>apple</code>.
        Instead, if we want to match all queries that contained the word <code>apple</code>, we will use
        the <code>contains</code> match instead.</p>

      {% code_block create-update-override %}
      ```javascript
      override = {
        "rule": {
          "query": "apple",
          "match": "exact"
        },
        "includes": [
          {"id": "422", "position": 1},
          {"id": "54", "position": 2}
        ],
        "excludes": [
          {"id": "287"}
        ]
      }

      // Creates/updates an override called `customize-apple` in the `companies` collection
      client.collections('companies').overrides().upsert('customize-apple', override)
      ```

      ```php
      $override = [
        "rule" => [
          "query" => "apple",
          "match" => "exact"
        ],
        "includes" => [
          ["id" => "422", "position" => 1],
          ["id" => "54", "position" => 2]
        ],
        "excludes" => [
          ["id" => "287"]
        ]
      ]

      # Creates/updates an override called `customize-apple` in the `companies` collection
      $client->collections['companies']->overrides->upsert('customize-apple', $override)
      ```

      ```python
      override = {
        "rule": {
          "query": "apple",
          "match": "exact"
        },
        "includes": [
          {"id": "422", "position": 1},
          {"id": "54", "position": 2}
        ],
        "excludes": [
          {"id": "287"}
        ]
      }

      # Creates/updates an override called `customize-apple` in the `companies` collection
      client.collections['companies'].overrides.upsert('customize-apple', override)
      ```

      ```ruby
      override = {
        "rule" => {
          "query" => "apple",
          "match" => "exact"
        },
        "includes" => [
          {"id" => "422", "position" => 1},
          {"id" => "54", "position" => 2}
        ],
        "excludes" => [
          {"id" => "287"}
        ]
      }

      # Creates/updates an override called `customize-apple` in the `companies` collection
      client.collections['companies'].overrides.upsert('customize-apple', override)
      ```

      ```shell
      curl "http://localhost:8108/collections/companies/overrides/customize-apple" -X PUT \
      -H "Content-Type: application/json" \
      -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
        "rule": {
          "query": "apple",
          "match": "exact"
        },
        "includes": [
          {"id": "422", "position": 1},
          {"id": "54", "position": 2}
        ],
        "excludes": [
          {"id": "287"}
        ]
      }'
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "id": "customize-apple",
        "excludes": [
          {
            "id": "287"
          }
        ],
        "includes": [
          {
            "id": "422",
            "position": 1
          },
          {
            "id": "54",
            "position": 2
          }
        ],
        "rule": {
          "match": "exact",
          "query": "apple"
        }
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>PUT ${TYPESENSE_HOST}/collections/:collection/overrides/:id</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>excludes</td>
          <td>no</td>
          <td>List of document <code>id</code>s that should be excluded from the search results.</td>
        </tr>
        <tr>
          <td>includes</td>
          <td>no</td>
          <td>List of document <code>id</code>s that should be included in the search results with their
            corresponding <code>position</code>s.</td>
        </tr>
        <tr>
          <td>rule.query</td>
          <td>yes</td>
          <td>Indicates what search queries should be overridden.</td>
        </tr>
        <tr>
          <td>rule.match</td>
          <td>yes</td>
          <td>Indicates whether the match on the query term should be <code>exact</code> or <code>contains</code>.</td>
        </tr>
      </table>

      <hr />

      <h4 id="list-overrides">List all overrides</h4>

      <p>Listing all overrides associated with a given collection.</p>

      {% code_block list-overrides %}
      ```javascript
      client.collections('companies').overrides().retrieve
      ```

      ```php
      $client->collections['companies']->overrides->retrieve()
      ```

      ```python
      client.collections['companies'].overrides.retrieve()
      ```

      ```ruby
      client.collections['companies'].overrides.retrieve
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
      "http://localhost:8108/collections/companies/overrides"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "overrides":[
          {
            "id":"customize-apple",
            "excludes":[
              {
                "id":"287"
              }
            ],
            "includes":[
              {
                "id":"422",
                "position":1
              },
              {
                "id":"54",
                "position":2
              }
            ],
            "rule":{
              "match":"exact",
              "query":"apple"
            }
          }
        ]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/overrides</code></p>

      <hr />

      <h4 id="delete-override">Delete an override</h4>

      <p>Deleting an override associated with a collection.</p>

      {% code_block delete-override %}
      ```javascript
      client.collections('companies').overrides('customize-apple').delete()
      ```

      ```php
      $client->collections['companies']->overrides['customize-apple'].delete()
      ```

      ```python
      client.collections['companies'].overrides['customize-apple'].delete()
      ```

      ```ruby
      client.collections['companies'].overrides['customize-apple'].delete
      ```

      ```shell
      curl "http://localhost:8108/collections/companies/overrides/customize-apple" -X DELETE \
      -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block delete-alias-response %}
      ```json
      {
        "id": "customize-apple"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>DELETE ${TYPESENSE_HOST}/collections/:collection/overrides/:id</code></p>
      <hr />

      <h3 id="aliases">Collection Alias</h3>

      <p>An alias is a virtual collection name that points to a real collection. If you're familiar with
        symbolic links on Linux, it's very similar to that. </p>

      <p>Aliases are useful when you want to reindex your
        data in the background on a new collection and switch your application to it without any changes
        to your code. Let's take an example.</p>

      <p>Let's say we have a collection called <code>companies_june10</code> and an alias
         called <code>companies</code> pointing to that collection.</p>

      <p><code>collection ---> companies_june10</code></p>

      <p>On the next day (June 11), we will create a new collection called <code>companies_june11</code>
        and start indexing the documents in the background into this collection. When we are done indexing,
        if we updated the <code>companies</code> alias to point to this new collection,
        your application would immediately start querying against the freshly indexed collection.</p>

      <p><code>collection ---> companies_june11</code></p>

      <p>Convenient isn't it? Let's now look at how we can create, update and manage aliases.</p>

      <hr />

      <h4 id="create-update-alias">Create or Update an alias</h4>

      {% code_block create-update-alias %}
      ```javascript
        aliased_collection = {
          'collection_name': 'companies_june11'
        }

        // Creates/updates an alias called `companies` to the `companies_june11` collection
        client.aliases().upsert('companies', aliased_collection)
      ```

      ```php
          $aliasedCollection = [
            'collection_name' => 'companies_june11'
          ]

          # Creates/updates an alias called `companies` to the `companies_june11` collection
          $client->aliases->upsert('companies', $aliasedCollection)
      ```

      ```python
          aliased_collection = {
            'collection_name': 'companies_june11'
          }

          # Creates/updates an alias called `companies` to the `companies_june11` collection
          client.aliases.upsert('companies', aliased_collection)
      ```

      ```ruby
          aliased_collection = {
            'collection_name' => 'companies_june11'
          }

          # Creates/updates an alias called `companies` to the `companies_june11` collection
          client.aliases.upsert('companies', aliased_collection)
      ```

      ```shell
        curl "http://localhost:8108/aliases/companies" -X PUT \
            -H "Content-Type: application/json" \
            -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
                "collection_name": "companies_june11"
            }'
        ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "name": "companies",
        "collection_name": "companies_june11",
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>PUT ${TYPESENSE_HOST}/aliases/:alias</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>collection_name</td>
          <td>yes</td>
          <td>Name of the collection you wish to map the alias to.</td>
        </tr>
      </table>

      <hr />

      <h4 id="retrieve-alias">Retrieve an alias</h4>

      <p>We can find out which collection an alias points to by fetching it.</p>

      {% code_block retrieve-alias %}
      ```javascript
        client.aliases('companies').retrieve()
      ```

      ```php
        $client->aliases['companies']->retrieve()
      ```

      ```python
        client.aliases['companies'].retrieve()
      ```

      ```ruby
        client.aliases['companies'].retrieve
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
            "http://localhost:8108/aliases/companies"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
        {
          "name": "companies",
          "collection_name": "companies_june11",
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/aliases/:alias</code></p>

      <hr />

      <h4 id="list-aliases">List all aliases</h4>

      <p>List all aliases and the corresponding collections that they map to.</p>

      {% code_block list-aliases %}
      ```javascript
      client.aliases().retrieve()
      ```

      ```php
      $client->aliases->retrieve()
      ```

      ```python
      client.aliases.retrieve()
      ```

      ```ruby
      client.aliases.retrieve
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
           "http://localhost:8108/aliases"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "aliases": [
          {
            "name": "companies",
            "collection_name": "companies_june11"
          },
          {
            "name": "employees",
            "collection_name": "employees_june11"
          }
        ]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/aliases</code></p>

      <hr />

      <h4 id="delete-alias">Delete an alias</h4>

      {% code_block delete-alias %}
      ```javascript
        client.aliases('companies').delete()
      ```

      ```php
        $client->aliases['companies']->delete()
      ```

      ```python
        client.aliases['companies'].delete()
      ```

      ```ruby
        client.aliases['companies'].delete
      ```

      ```shell
      curl "http://localhost:8108/aliases/companies" -X DELETE
          -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block delete-alias-response %}
      ```json
      {
        "name": "companies",
        "collection_name": "companies_june11"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>DELETE ${TYPESENSE_HOST}/aliases/:alias</code></p>

      <hr>

      <h3 id="synonyms">Synonyms</h3>

      <p>The synonyms feature allows you to define search terms that should be considered equivalent.
        For eg: when you define a synonym for <code>sneaker</code> as <code>shoe</code>,
        searching for <code>sneaker</code> will now return all records with the word <code>shoe</code> in them,
        in addition to records with the word <code>sneaker</code>.
      </p>

      <p>Typesense supports two types of synonyms:</p>
      <dl>
        <dt>Multi-way synonyms</dt>
        <dd>Defining words <code>ABC, DEF and XYZ</code> (for eg) as multi-way synonyms will cause searches for any one of those words (eg: <code>DEF</code>) to return records containing at least one of the words in the synonym set (eg: records with <code>ABC</code> or <code>DEF</code> or <code>KYX</code> are returned).</dd>
        <dt>One-way synonyms</dt>
        <dd>Defining the words <code>DEF</code> and <code>XYZ</code> as one-way synonyms of <code>ABC</code> will cause searches for
          <code>DEF</code> or <code>XYZ</code> to return records containing <code>ABC</code>.
        </dd>
      </dl>

      <h4 id="create-update-multi-synonym">Create or update a multi-way synonym</h4>

      {% code_block create-update-synonym %}
      ```javascript
      synonym = {
        "synonyms": ["blazer", "coat", "jacket"]
      }

      // Creates/updates a synonym called `coat-synonyms` in the `products` collection
      client.collections('products').synonyms().upsert('coat-synonyms', synonym)
      ```

      ```php
      $synonym = [
        "synonyms" => ["blazer", "coat", "jacket"]
      ]

      # Creates/updates a synonym called `coat-synonyms` in the `products` collection
      $client->collections['products']->synonyms->upsert('coat-synonyms', $synonym)
      ```

      ```python
      synonym = {
        "synonyms": ["blazer", "coat", "jacket"]
      }

      # Creates/updates a synonym called `coat-synonyms` in the `products` collection
      client.collections['products'].synonyms.upsert('coat-synonyms', synonym)
      ```

      ```ruby
      synonym = {
        "synonyms" => ["blazer", "coat", "jacket"]
      }

      # Creates/updates a synonym called `coat-synonyms` in the `products` collection
      client.collections['products'].synonyms.upsert('coat-synonyms', synonym)
      ```

      ```shell
      curl "http://localhost:8108/collections/products/synonyms/coat-synonyms" -X PUT \
      -H "Content-Type: application/json" \
      -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
        "synonyms": ["blazer", "coat", "jacket"]
      }'
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-multi-way-synonym-response %}
      ```json
      {
        "id": "coat-synonyms",
        "synonyms": ["blazer", "coat", "jacket"]
      }
      ```
      {% endcode_block %}

      <h4 id="create-update-1-way-synonym">Create or update a one-way synonym</h4>

      {% code_block create-update-synonym %}
      ```javascript
      synonym = {
        "root": "blazer",
        "synonyms": ["coat", "jacket"]
      }

      // Creates/updates a synonym called `blazer-synonyms` in the `products` collection
      client.collections('products').synonyms().upsert('blazer-synonyms', synonym)
      ```

      ```php
      $synonym = [
        "root" => "blazer",
        "synonyms" => ["coat", "jacket"]
      ]

      # Creates/updates a synonym called `blazer-synonyms` in the `products` collection
      $client->collections['products']->synonyms->upsert('blazer-synonyms', $synonym)
      ```

      ```python
      synonym = {
        "root": "blazer",
        "synonyms": ["coat", "jacket"]
      }

      # Creates/updates a synonym called `blazer-synonyms` in the `products` collection
      client.collections['products'].synonyms.upsert('blazer-synonyms', synonym)
      ```

      ```ruby
      synonym = {
        "root" => "blazer",
        "synonyms" => ["coat", "jacket"]
      }

      # Creates/updates a synonym called `coat-synonyms` in the `products` collection
      client.collections['products'].synonyms.upsert('coat-synonyms', synonym)
      ```

      ```shell
      curl "http://localhost:8108/collections/products/synonyms/coat-synonyms" -X PUT \
      -H "Content-Type: application/json" \
      -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
        "root": "blazer",
        "synonyms": ["coat", "jacket"]
      }'
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-1-way-synonym-response %}
      ```json
      {
        "id":"coat-synonyms",
        "root":"blazer",
        "synonyms": ["coat", "jacket"]
      }
      ```
      {% endcode_block %}


      <h5>Definition</h5>
      <p><code>PUT ${TYPESENSE_HOST}/collections/:collection/synonyms/:id</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>synonyms</td>
          <td>yes</td>
          <td>Array of words that should be considered as synonyms.</td>
        </tr>
        <tr>
          <td>root</td>
          <td>no</td>
          <td>For 1-way synonyms, indicates the root word that words in the <code>synonyms</code> parameter map to.</td>
        </tr>
      </table>

      <hr />

      <h4 id="retrieve-synonym">Retrieve a synonym</h4>

      <p>We can retrieve a single synonym.</p>

      {% code_block retrieve-alias %}
      ```javascript
      client.collections('products').synonyms('coat-synonyms').retrieve
      ```

      ```php
      $client->collections['products']->synonyms['coat-synonyms']->retrieve()
      ```

      ```python
      client.collections['products'].synonyms['coat-synonyms'].retrieve()
      ```

      ```ruby
      client.collections['products'].synonyms['coat-synonyms'].retrieve
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
      "http://localhost:8108/collections/products/synonyms/coat-synonyms"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-synonym-response %}
      ```json
      {
        "id": "coat-synonyms",
        "root":"",
        "synonyms": ["blazer", "coat", "jacket"]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/synonyms/:id</code></p>

      <hr />

      <h4 id="list-synonyms">List all synonyms</h4>

      <p>List all synonyms associated with a given collection.</p>

      {% code_block list-synonyms %}
      ```javascript
      client.collections('products').synonyms().retrieve
      ```

      ```php
      $client->collections['products']->synonyms->retrieve()
      ```

      ```python
      client.collections['products'].synonyms.retrieve()
      ```

      ```ruby
      client.collections['products'].synonyms.retrieve
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
      "http://localhost:8108/collections/products/synonyms"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-synonyms-response %}
      ```json
      {
        "synonyms":[
          {
            "id": "coat-synonyms",
            "root": "blazer",
            "synonyms": ["coat", "jacket"]
          }
        ]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/synonyms</code></p>

      <hr />

      <h4 id="delete-synonym">Delete a synonym</h4>

      <p>Delete a synonym associated with a collection.</p>

      {% code_block delete-synonym %}
      ```javascript
      client.collections('books').synonyms('coat-synonyms').delete()
      ```

      ```php
      $client->collections['books']->synonyms['coat-synonyms'].delete()
      ```

      ```python
      client.collections['books'].synonyms['coat-synonyms'].delete()
      ```

      ```ruby
      client.collections['books'].synonyms['coat-synonyms'].delete
      ```

      ```shell
      curl "http://localhost:8108/collections/books/synonyms/coat-synonyms" -X DELETE \
      -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block delete-synonym-response %}
      ```json
      {
        "id": "coat-synonyms"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>DELETE ${TYPESENSE_HOST}/collections/:collection/synonyms/:id</code></p>
      <hr />


      <h3 id="cluster-operations">Cluster Operations</h3>

      <h4 id="cluster-operations-snapshot">Create snapshot (for backups)</h4>

      <p>Creates a point-in-time snapshot of a Typesense node's state and data in the specified directory.</p>

      <p>You can then backup the snapshot directory that gets created and later restore it as a data directory, as needed.</p>

      {% code_block operation-snapshot %}
      ```javascript
      client.operations.perform('snapshot', {'snapshot_path': '/tmp/typesense-data-snapshot'})
      ```

      ```php
      $client->operations->perform("snapshot", ["snapshot_path" => "/tmp/typesense-data-snapshot"])
      ```

      ```python
      client.operations.perform('snapshot', {'snapshot_path': '/tmp/typesense-data-snapshot'})
      ```

      ```ruby
      client.operations.perform('snapshot', {'snapshot_path': '/tmp/typesense-data-snapshot'})
      ```

      ```shell
      curl "http://localhost:8108/operations/snapshot?snapshot_path=/tmp/typesense-data-snapshot" -X POST \
      -H "Content-Type: application/json" \
      -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block operation-snapshot-response %}
      ```json
      {
        "success": true
      }
      ```
      {% endcode_block %}


      <h5>Definition</h5>
      <p><code>POST ${TYPESENSE_HOST}/operations/snapshot</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>snapshot_path</td>
          <td>yes</td>
          <td>The directory on the server where the snapshot should be saved.</td>
        </tr>
      </table>

      <h4 id="cluster-operations-vote">Re-elect Leader</h4>

      <p>Triggers a follower node to initiate the raft voting process, which triggers leader re-election.</p>

      <p>The follower node that you run this operation against will become the new leader, once this command succeeds.</p>

      {% code_block operation-vote %}
      ```javascript
      client.operations.perform('vote')
      ```

      ```php
      $client->operations->perform("vote")
      ```

      ```python
      client.operations.perform('vote')
      ```

      ```ruby
      client.operations.perform('vote')
      ```

      ```shell
      curl "http://localhost:8108/operations/vote" -X POST \
      -H "Content-Type: application/json" \
      -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block operation-vote-response %}
      ```json
      {
        "success": true
      }
      ```
      {% endcode_block %}


      <h5>Definition</h5>
      <p><code>POST ${TYPESENSE_HOST}/operations/vote</code></p>


      <h4 id="config-slow-request-log">Toggle Slow Request Log</h4>

      <p>Enable logging of requests that take over a defined threshold of time. </p>

      <p>Default: <code>-1</code> which disables slow request logging.</p>

      <p>Slow requests are logged to the primary log file, with the prefix <code>SLOW REQUEST</code>.</p>

      {% code_block config-slow-query-log %}

      ```shell
      curl "http://localhost:8108/config" \
              -X POST -H "Content-Type: application/json" \
              -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
              -d '{"log-slow-requests-time-ms": 2000}'
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block config-slow-query-log-response %}
      ```json
      {
        "success": true
      }
      ```
      {% endcode_block %}


      <h5>Definition</h5>
      <p><code>POST ${TYPESENSE_HOST}/config</code></p>

      <hr />

      <h3 id="whats-new">What's new in 0.19.0</h3>

      <p>This release contains new features, performance improvements and important bug fixes.</p>

      <h5>New Features</h5>
      <ul>
        <li>Ability to send multiple search requests in a single HTTP request</li>
        <li>Ability to limit total number of results that can be fetched using <code>limit_hits</code> search parameter</li>
        <li>Support for slow request logs</li>
        <li>Support numerical range operator in <code>filter_by</code></li>
      </ul>

      <h5>Enhancements</h5>
      <ul>
        <li>Improved <code>filter_by</code> & <code>facet_by</code> performance during searches</li>
        <li>Detailed stack traces with additional symbols and line numbers</li>
        <li>Keep existing config files in place when updating RPM package</li>
        <li><code>/operations/snapshot</code> endpoint no longer blocks write operations</li>
      </ul>

      <h5>Bug Fixes</h5>
      <ul>
        <li>Improved facet query validation</li>
        <li>Improved override validation</li>
        <li>Fixed a crash when import requests are aborted</li>
        <li>Fixed a crash when integer filter values are used for creating scoped api keys</li>
      </ul>

      <h5>Deprecations</h5>
      <ul>
        <li>The <code>max_hits</code> search parameter is deprecated and is no longer necessary.</li>
      </ul>

      <h3 id="errors">API errors</h3>

      <p>Typesense API uses standard HTTP response codes to indicate the success or failure of a request.</p>

      <p>Codes in the 2xx range indicate success, codes in the 4xx range indicate an error given the information provided
      (e.g. a required parameter was omitted), and codes in the 5xx range indicate an error with the Typesense service itself.
      </p>

      <table class="table table-striped">
        <tr>
          <th>Error Code</th>
          <th>Meaning</th>
        </tr>

        <tr>
          <td>400</td>
          <td>Bad Request - The request could not be understood due to malformed syntax.</td>
        </tr>

        <tr>
          <td>401</td>
          <td>Unauthorized - Your API key is wrong.</td>
        </tr>

        <tr>
          <td>404</td>
          <td>Not Found - The requested resource is not found.</td>
        </tr>

        <tr>
          <td>409</td>
          <td>Conflict - When a resource already exists.</td>
        </tr>

        <tr>
          <td>422</td>
          <td>Unprocessable Entity - Request is well-formed, but cannot be processed.</td>
        </tr>

        <tr>
          <td>503</td>
          <td>Service Unavailable - Weâ€™re temporarily offline. Please try again later.</td>
        </tr>
      </table>
  </div>

  <div class="col-md-1 row no-gutters"></div>

  <div class="col-md-3 row no-gutters">
      <nav id="navbar-docs" class="navbar navbar-light navbar-text">
        <nav class="nav nav-pills flex-column sticky-top">
          <a class="nav-link" href="#introduction">Introduction</a>
          <a class="nav-link" href="#api-clients">API clients</a>
          <a class="nav-link" href="#authentication">Authentication</a>
          <a class="nav-link" href="#usage">Usage</a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#create-collection">Create a collection</a>
            <a class="nav-link ml-3 my-1" href="#index-document">Index a document</a>
            <a class="nav-link ml-3 my-1" href="#search-collection">Search a collection</a>
            <a class="nav-link ml-3 my-1" href="#multi-search">Federated / Multi search</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-document">Retrieve a document</a>
            <a class="nav-link ml-3 my-1" href="#update-document">Update a document</a>
            <a class="nav-link ml-3 my-1" href="#delete-document">Deleting documents</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-collection">Retrieve a collection</a>
            <a class="nav-link ml-3 my-1" href="#export-documents">Export documents</a>
            <a class="nav-link ml-3 my-1" href="#import-documents">Import documents</a>
            <a class="nav-link ml-3 my-1" href="#list-collection">List all collections</a>
            <a class="nav-link ml-3 my-1" href="#drop-collection">Drop a collection</a>
          </nav>
          <a class="nav-link collapsed" href="#api-keys">Manage API Keys </a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#create-key">Create a key</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-key">Retrieve a key</a>
            <a class="nav-link ml-3 my-1" href="#list-keys">List all keys</a>
            <a class="nav-link ml-3 my-1" href="#delete-key">Delete a key</a>
            <a class="nav-link ml-3 my-1" href="#generate-scoped-search-key">Generate scoped search key</a>
          </nav>
          <a class="nav-link collapsed" href="#curation">Curation / Merchandizing </a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#curation">Create/Update an override</a>
            <a class="nav-link ml-3 my-1" href="#list-overrides">List all overrides</a>
            <a class="nav-link ml-3 my-1" href="#delete-override">Delete an override</a>
          </nav>
          <a class="nav-link collapsed" href="#aliases">Collection Alias</a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#aliases">Create/Update an alias</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-alias">Retrieve an alias</a>
            <a class="nav-link ml-3 my-1" href="#list-aliases">List all aliases</a>
            <a class="nav-link ml-3 my-1" href="#delete-alias">Delete an alias</a>
          </nav>
          <a class="nav-link collapsed" href="#synonyms">Synonyms</a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#create-update-multi-synonym">Create/Update a synonym</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-synonym">Retrieve a synonym</a>
            <a class="nav-link ml-3 my-1" href="#list-synonyms">List all synonyms</a>
            <a class="nav-link ml-3 my-1" href="#delete-synonym">Delete a synonym</a>
          </nav>
          <a class="nav-link collapsed" href="#cluster-operations">Cluster Operations</a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#cluster-operations-snapshot">Create snapshot</a>
            <a class="nav-link ml-3 my-1" href="#cluster-operations-vote">Re-elect leader</a>
            <a class="nav-link ml-3 my-1" href="#config-slow-request-log">Toggle slow request log</a>
          </nav>
          <a class="nav-link" href="#whats-new">What's new in 0.19.0</a>
          <a class="nav-link" href="#errors">API errors</a>
        </nav>
      </nav>
  </div>
</div>
