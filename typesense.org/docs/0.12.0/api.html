---
layout: page
title: API Documentation
nav_label: api
---

<div class="row no-gutters">
    <div id="doc-col" class="col-md-8">
      {% include versions.html %}

      <h3 id="introduction">Introduction</h3>
      <p>Welcome to the Typesense API documentation. This documentation itself is open source.
        Please leave your feedback as issues on the
        <a href="https://github.com/typesense/typesense-website/issues">GitHub repo</a> or send us a pull-request
        to contribute edits.</p>

      <p><mark>To learn how to install and run Typesense, see our <a href="/guide">getting started guide</a> instead.</mark></p>

      <h3 id="api-clients">API clients</h3>

      <p>At the moment, we have API clients for Javascript, Python, and Ruby. </p>
      <p>We recommend that you use our API client library if it is available for your language.</p>

      {% code_block install %}
        ```ruby
           gem install typesense
        ```

        ```python
           pip install typesense
        ```

        ```javascript
          // Node.js
          npm install typesense

          // Browser
          <script src="dist/typesense.min.js"></script>
        ```
      {% endcode_block %}

      <p>If you're using our Javascript client to access Typesense directly from the browser, be sure to start the
        Typesense server with the <code>--enable-cors</code> flag. </p>

      <h3 id="authentication">Authentication</h3>

      {% code_block authenticate %}
      ```ruby
        require 'typesense'

        client = Typesense::Client.new(
          nodes: [
            {
              host:     'localhost',
              port:     8108,
              protocol: 'http'
            }
          ],

          api_key:  '<API_KEY>',
          connection_timeout_seconds: 2
        )
      ```

      ```python
        import typesense

        client = typesense.Client({
          'nodes': [{
            'host': 'localhost',
            'port': '8108',
            'protocol': 'http',
          }],

          'api_key': '<API_KEY>',
          'connection_timeout_seconds': 2
        })
      ```

      ```javascript
        /*
         *  Our Javascript client library works on both the client and the browser.
         *  When using the library on the browser, please be sure to use the
         *  search-only API Key rather than the master API key since the latter
         *  has write access to Typesense and you don't want to expose that.
         */
        let client = new Typesense.Client({
          'nodes': [{
            'host': 'localhost',
            'port': '8108',
            'protocol': 'http',
          }],

          'apiKey': '<API_KEY>'
          'connectionTimeoutSeconds': 2
        })
      ```


      ```shell
          # API authentication is done via the `X-TYPESENSE-API-KEY` HTTP header.
          curl -H "X-TYPESENSE-API-KEY: <API_KEY>" "http://localhost:8108/collections"
      ```
      {% endcode_block %}

      <h3 id="usage">Usage</h3>

      <p>In Typesense, a group of related documents is called a <code>collection</code>. A <code>collection</code> is roughly
        equivalent to a table in a relational database.
      </p>

      <h4 id="create-collection">Create a collection</h4>

      <p>When a <code>collection</code> is created, we give it a name and describe the fields that will be indexed
        from the documents that are added to the <code>collection</code>.</p>

      <p>
        Your documents can contain other fields not mentioned in the collection's schema - they will be stored but
        not indexed.
      </p>

      {% code_block create-collection %}
      ```ruby
        schema = {
          'name'      => 'companies',
          'fields'    => [
            {
              'name'  => 'company_name',
              'type'  => 'string'
            },
            {
              'name'  => 'num_employees',
              'type'  => 'int32'
            },
            {
              'name'  => 'country',
              'type'  => 'string',
              'facet' => true
            }
          ],
          'default_sorting_field' => 'num_employees'
        }

        client.collections.create(schema)
      ```
      ```python
        schema = {
          'name': 'companies',
          'fields': [
            {
              'name'  :  'company_name',
              'type'  :  'string'
            },
            {
              'name'  :  'num_employees',
              'type'  :  'int32'
            },
            {
              'name'  :  'country',
              'type'  :  'string',
              'facet' :  True
            }
          ],
          'default_sorting_field': 'num_employees'
        }

        client.collections.create(schema)
      ```

      ```javascript
        let schema = {
          'name': 'companies',
          'num_documents': 0,
          'fields': [
            {
              'name': 'company_name',
              'type': 'string',
              'facet': false
            },
            {
              'name': 'num_employees',
              'type': 'int32',
              'facet': false
            },
            {
              'name': 'country',
              'type': 'string',
              'facet': true
            }
          ],
          'default_sorting_field': 'num_employees'
        }

        client.collections().create(schema)
      ```

      ```shell
        curl "http://localhost:8108/collections" -X POST -H "Content-Type: application/json" \
               -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
                 "name": "companies",
                 "fields": [
                   {"name": "company_name", "type": "string" },
                   {"name": "num_employees", "type": "int32" },
                   {"name": "country", "type": "string", "facet": true }
                 ],
                 "default_sorting_field": "num_employees"
               }'
      ```
      {% endcode_block %}


      <h5>Sample response</h5>

      {% code_block create-collection-response %}
      ```json
        {
          "name": "companies",
          "num_documents": 0,
          "fields": [
            {"name": "company_name", "type": "string" },
            {"name": "num_employees", "type": "int32" },
            {"name": "country", "type": "string", "facet": true }
          ],
          "default_sorting_field": "num_employees"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>POST ${TYPESENSE_HOST}/collections</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>name</td>
          <td>yes</td>
          <td>Name of the collection you wish to create.</td>
        </tr>
        <tr>
          <td>fields</td>
          <td>yes</td>
          <td>
            <p>A list of fields that you wish to index for querying, filtering and faceting. For each field, you
            have to specify the <code>name</code> and <code>type</code>.</p>

            <p><strong>Declaring a field as optional</strong></p>
            <p>A field can be declared as optional by setting <code>"optional": true</code>.</p>

            <p><strong>Declaring a field as a facet</strong></p>

            <p>A field can be declared as a facetable field by setting <code>"facet": true</code>.</p>
            <p>Faceted fields are indexed <strong>verbatim</strong> without any tokenization or preprocessing.
              For example, if you are building a product search, <code>color</code> and <code>brand</code> could be
              defined as facet fields.</p>
          </td>
        </tr>
        <tr>
          <td>default_sorting_field</td>
          <td>yes</td>
          <td>
            <p>The name of an <code>int32</code> / <code>float</code> field that determines the order in which
            the search results are ranked when a <code>sort_by</code> clause is not provided during searching.
              This field must indicate some kind of popularity. For example, in a product search
              application, you could define <code>num_reviews</code> field as the <code>default_sorting_field</code>.
            </p>

            <p>Additionally, when a word in a search query matches multiple possible words (either because of a typo or
              during a prefix search), this parameter is used to rank such equally matching tokens.
              For e.g. both "john" and "joan" are 1-typo away from "jofn". Similarly, in a
              prefix search, both "apple" and "apply" would match the prefix "app".</p>
          </td>
        </tr>
      </table>

      <h5>Supported search field types</h5>

      <p>Typesense allows you to index the following types of fields:</p>

      <table class="table table-striped">
        <tr><td><code>string</code></td></tr>
        <tr><td><code>int32</code></td></tr>
        <tr><td><code>int64</code></td></tr>
        <tr><td><code>float</code></td></tr>
        <tr><td><code>bool</code></td></tr>
      </table>

      <p>You can define an array or multi-valued field by suffixing a <code>[]</code> at the end:</p>

      <table class="table table-striped">
        <tr><td><code>string[]</code></td></tr>
        <tr><td><code>int32[]</code></td></tr>
        <tr><td><code>int64[]</code></td></tr>
        <tr><td><code>float[]</code></td></tr>
        <tr><td><code>bool[]</code></td></tr>
      </table>


      <h4 id="index-document">Index a document</h4>

      <p>A document to be indexed in a given collection must conform to the schema of the collection.</p>

      <p>
        If the document contains an `id` field of type `string`, Typesense would use that field as the identifier for the
        document. Otherwise, Typesense would assign an identifier of its choice to the document.
      </p>

      {% code_block index-document %}
        ```ruby
        document = {
          'id'            => '124',
          'company_name'  => 'Stark Industries',
          'num_employees' => 5215,
          'country'       => 'USA'
        }

        client.collections['companies'].documents.create(document)
        ```

        ```python
        document = {
          'id': '124',
          'company_name': 'Stark Industries',
          'num_employees': 5215,
          'country': 'USA'
        }

        client.collections['companies'].documents.create(document)
        ```

        ```javascript
          let document = {
            'id': '124',
            'company_name': 'Stark Industries',
            'num_employees': 5215,
            'country': 'USA'
          }

          client.collections('companies').documents().create(document)
        ```

        ```shell
        curl "http://localhost:8108/collections/companies/documents" -X POST \
                -H "Content-Type: application/json" \
                -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
                -d '{
                  "id": "124",
                  "company_name": "Stark Industries",
                  "num_employees": 5215,
                  "country": "USA"
                }'
        ```
      {% endcode_block %}

      <h5>Sample Response</h5>

      {% code_block index-document-response %}
      ```json
      {
        "id": "124",
        "company_name": "Stark Industries",
        "num_employees": 5215,
        "country": "USA"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>POST ${TYPESENSE_HOST}/collections/:collection/documents</code></p>

      <h4 id="search-collection">Search a collection</h4>

      <p>In Typesense, a search consists of a query against one or more text fields and a list of filters against numerical or
        facet fields. You can also sort and facet your results.</p>

      <p>Due to performance reasons, Typesense limits searches to a maximum of 500 results.</p>

      {% code_block search-collection %}
      ```ruby
        search_parameters = {
          'q'         => 'stark',
          'query_by'  => 'company_name',
          'filter_by' => 'num_employees:>100',
          'sort_by'   => 'num_employees:desc'
        }

        client.collections['companies'].documents.search(search_parameters)
      ```

      ```python
        search_parameters = {
          'q'         : 'stark',
          'query_by'  : 'company_name',
          'filter_by' : 'num_employees:>100',
          'sort_by'   : 'num_employees:desc'
        }

        client.collections['companies'].documents.search(search_parameters)
      ```

      ```javascript
        let searchParameters = {
          'q'         : 'stark',
          'query_by'  : 'company_name',
          'filter_by' : 'num_employees:>100',
          'sort_by'   : 'num_employees:desc'
        }

        client.collections('companies').documents().search(searchParameters)
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
        "http://localhost:8108/collections/companies/documents/search\
        ?q=stark&query_by=company_name&filter_by=num_employees:>100\
        &sort_by=num_employees:desc"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block search-collection-response %}
      ```json
        {
          "facet_counts": [],
          "found": 1,
          "took_ms": 1,
          "hits": [
            {
              "highlights": [
                {
                  "field": "company_name",
                  "snippet": "<mark>Stark</mark> Industries"
                }
              ],
              "document": {
                "id": "124",
                "company_name": "Stark Industries",
                "num_employees": 5215,
                "country": "USA"
              }
            }
          ]
        }
      ```
      {% endcode_block %}

      <p>When a <code>string[]</code> field is queried, the <code>highlights</code> structure would include the
        corresponding matching array indices of the snippets. For e.g:</p>

      {% code_block highlights-arrray-response %}
      ```json
        {
              ...
              "highlights": [
                {
                  "field": "addresses",
                  "indices": [0,2],
                  "snippets": [
                    "10880 <mark>Malibu</mark> Point, <mark>Malibu,</mark> CA 90265",
                    "10000 <mark>Malibu</mark> Point, <mark>Malibu,</mark> CA 90265"
                  ]
                }
              ],
              ...
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/documents/search</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>q</td>
          <td>yes</td>
          <td>
            <p>The query text to search for in the collection.</p>
            <p>
                Use <code>*</code> as the search string to return all documents. This is typically useful when used in
                conjunction with <code>filter_by</code>.</p>
                <p>For example, to return all documents that match a filter, use: <br/>
                <code>q=*&filter_by=num_employees:10</code> </p>
          </td>
        </tr>
        <tr>
          <td>query_by</td>
          <td>yes</td>
          <td>
            <p>One or more <code>string</code> / <code>string[]</code> fields that should be queried against.
              Separate multiple fields with a comma: <code>company_name, country</code></p>

            <p>The order of the fields is important: a record that matches on a field earlier in the list is
              considered more relevant than a record matched on a field later in the list.
              So, in the example above, documents that match on the <code>company_name</code> field are ranked above
              documents matched on the <code>country</code> field.</p></td>
        </tr>
        <tr>
          <td>max_hits</td>
          <td>no</td>
          <td><p>Maximum number of hits returned. Increasing this value might increase search latency.</p>
            <p>Use <code>all</code> to return all hits found.</p>
            <p>Default: <code>500</code></p>
          </td>
        </tr>
        <tr>
          <td>prefix</td>
          <td>no</td>
          <td><p>Boolean field to indicate that the last word in the query should be treated as a prefix, and not as a whole
            word. This is necessary for building autocomplete and instant search interfaces.</p>
            <p>Default: <code>true</code></p>
          </td>
        </tr>
        <tr>
          <td>filter_by</td>
          <td>no</td>
          <td><p>Filter conditions for refining your search results.</p>
              <p>A field can be matched against one or more values.</p>
              <p><code>country: USA</code> <br />
                 <code>country: [USA, UK]</code>
              </p>

              <p>Separate multiple conditions with the <code>&&</code> operator.</p>
              <p><code>num_employees:>100 && country: [USA, UK]</code></p>

              <p>More examples:</p>

              <p><code>num_employees:10</code> <br />
                 <code>num_employees:<=10</code>
              </p>
          </td>
        </tr>
        <tr>
          <td>sort_by</td>
          <td>no</td>
          <td>
            <p>A list of numerical fields and their corresponding sort orders that will be used for ordering your results.
            Separate multiple fields with a comma. Upto 3 sort fields can be specified.</p>
            <p>E.g. <code>num_employees:desc,year_started:asc</code></p>

            <p>The text similarity score is exposed as a special <code>_match_score</code> field that you can use
            in the list of sorting fields.</p>

            <p>If one or two sorting fields are specified, <code>_match_score</code> is used for
              tie breaking, as the last sorting field.</p>

            <p>Default:</p>

            <p>If no <code>sort_by</code> parameter is specified, results are sorted by:
              <code>_match_score:desc,default_sorting_field:desc</code>.</p>
          </td>
        </tr>
        <tr>
          <td>facet_by</td>
          <td>no</td>
          <td><p>A list of fields that will be used for faceting your results on. Separate multiple fields with a comma.</p></td>
        </tr>
        <tr>
          <td>max_facet_values</td>
          <td>no</td>
          <td><p>Maximum number of facet values to be returned.</p></td>
        </tr>
        <tr>
          <td>facet_query</td>
          <td>no</td>
          <td><p>Facet values that are returned can now be filtered via this parameter. The matching facet text is
            also highlighted. For example, when faceting by <code>category</code>, you can set
            <code>facet_query=category:shoe</code> to return only facet values that contain the prefix "shoe". </p>
          </td>
        </tr>
        <tr>
          <td>num_typos</td>
          <td>no</td>
          <td><p>Number of typographical errors (1 or 2) that would be tolerated.</p>

            <p><a href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">Damerauâ€“Levenshtein distance</a>
              is used to calculate the number of errors.</p>

            <p>Default: <code>2</code></p>
          </td>
        </tr>
        <tr>
          <td>page</td>
          <td>no</td>
          <td><p>Results from this specific page number would be fetched.</p></td>
        </tr>
        <tr>
          <td>per_page</td>
          <td>no</td>
          <td>
            <p>Number of results to fetch per page.</p>
            <p>Default: <code>10</code></p>
          </td>
        </tr>
        <tr>
          <td>include_fields</td>
          <td>no</td>
          <td><p>Comma-separated list of fields from the document to include in the search result.</p></td>
        </tr>
        <tr>
          <td>exclude_fields</td>
          <td>no</td>
          <td><p>Comma-separated list of fields from the document to exclude in the search result.</p></td>
        </tr>
        <tr>
          <td>highlight_full_fields</td>
          <td>no</td>
          <td>
            <p>Comma separated list of fields which should be highlighted fully without snippeting.</p>
            <p>Default: all fields will be snippeted.</p>
          </td>
        </tr>
        <tr>
          <td>snippet_threshold</td>
          <td>no</td>
          <td><p>Field values under this length will be fully highlighted, instead of showing a snippet of
              relevant portion.</p>
              <p>Default: <code>30</code></p>
          </td>
        </tr>
        <tr>
          <td>drop_tokens_threshold</td>
          <td>no</td>
          <td>
              <p>
                  If the number of results found for a specific query is less than this number, Typesense will attempt
                  to drop the tokens in the query until enough results are found. Tokens that have the least individual hits
                  are dropped first. Set <code>drop_tokens_threshold</code> to <code>0</code> to disable dropping of tokens.
              </p>
              <p>
                Default: <code>10</code>
              </p>
          </td>
        </tr>
        <tr>
          <td>typo_tokens_threshold</td>
          <td>no</td>
          <td>
            <p>
              If the number of results found for a specific query is less than this number, Typesense will attempt to
              look for tokens with more typos until enough results are found.
            </p>
            <p>
              Default: <code>100</code>
            </p>
          </td>
        </tr>
        <tr>
          <td>pinned_hits</td>
          <td>no</td>
          <td>
            <p>A list of records to unconditionally include in the search results at specific positions.</p>
            <p>An example use case would be to feature or promote certain items on the top of search results.</p>
            <p>A comma separated list of <code>record_id:hit_position</code>. Eg: to include a record with ID 123 at Position 1
              and another record with ID 456 at Position 5, you'd specify <code>123:1,456:5</code>.
            </p>
            <p>You could also use the Overrides feature to override search results based on rules.
              Overrides are applied first, followed by pinned_hits and finally hidden_hits.
            </p>
          </td>
        </tr>
        <tr>
          <td>hidden_hits</td>
          <td>no</td>
          <td>
            <p>A list of records to unconditionally hide from search results.</p>
            <p>A comma separated list of <code>record_id</code>s to hide. Eg: to hide records with IDs 123 and 456,
              you'd specify <code>123,456</code>.
            </p>
            <p>You could also use the Overrides feature to override search results based on rules.
              Overrides are applied first, followed by pinned_hits and finally hidden_hits.
            </p>
          </td>
        </tr>
      </table>

      <h4 id="retrieve-document">Retrieve a document</h4>

      Fetch an individual document from a collection by using its <code>id</code>.

      {% code_block retrieve-document %}
      ```ruby
        client.collections['companies'].documents['124'].retrieve
      ```

      ```python
        client.collections['companies'].documents['124'].retrieve()
      ```

      ```javascript
        client.collections('companies').documents('124').retrieve()
      ```

      ```shell
        $ curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X GET \
              "http://localhost:8108/collections/companies/documents/124"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block retrieve-document-response %}
      ```json
        {
          "id": "124",
          "company_name": "Stark Industries",
          "num_employees": 5215,
          "country": "USA"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/documents/:id</code></p>

      <h4 id="delete-document">Delete a document</h4>

      <p>Delete an individual document from a collection by using its <code>id</code>.</p>

      {% code_block delete-document %}
      ```ruby
        client.collections['companies'].documents['124'].delete
      ```

      ```python
        client.collections['companies'].documents('124').delete()
      ```

      ```javascript
        client.collections('companies').documents('124').delete()
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X DELETE \
            "http://localhost:8108/collections/companies/documents/124"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block delete-document-response %}
      ```json
        {
          "id": "124",
          "company_name": "Stark Industries",
          "num_employees": 5215,
          "country": "USA"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>DELETE ${TYPESENSE_HOST}/collections/:collection/documents/:id</code></p>

      <h4 id="retrieve-collection">Retrieve a collection</h4>

      <p>Retrieve the details of a collection, given its name.</p>

      {% code_block retrieve-collection %}
      ```ruby
        client.collections['companies'].retrieve
      ```

      ```python
        client.collections['companies'].retrieve()
      ```

      ```javascript
        client.collections('companies').retrieve()
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X GET
            "http://localhost:8108/collections/companies"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block retrieve-collection-response %}
      ```json
        {
          "name": "companies",
          "num_documents": 1250,
          "fields": [
            {"name": "company_name", "type": "string"},
            {"name": "num_employees", "type": "int32"},
            {"name": "country", "type": "string", "facet": true}
          ],
          "default_sorting_field": "num_employees"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection</code></p>

      <h4 id="export-documents">Export documents from a collection</h4>

      {% code_block export-documents %}
      ```ruby
        client.collections['companies'].documents.export
      ```

      ```python
        client.collections['companies'].documents.export()
      ```

      ```javascript
        client.collections('companies').documents().export()
      ```


      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X GET
            "http://localhost:8108/collections/companies/documents/export"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block export-documents-response %}
        ```ruby
          [
          "{\"id\": \"124\", \"company_name\": \"Stark Industries\", \"num_employees\": 5215, \
          \"country\": \"US\"}",
          "{\"id\": \"125\", \"company_name\": \"Future Technology\", \"num_employees\": 1232, \
          \"country\": \"UK\"}",
          "{\"id\": \"126\", \"company_name\": \"Random Corp.\", \"num_employees\": 531, \
          \"country\": \"AU\"}"
          ]
        ```

        ```python
          [u'{"company_name":"Stark Industries","country":"USA","id":"124","num_employees":5215}',\
          u'{"company_name":"Future Technology","country":"UK","id":"125","num_employees":1232}',\
          u'{"company_name":"Random Corp.","country":"AU","id":"126","num_employees":531}']
        ```

        ```javascript
          ['{"company_name":"Stark Industries","country":"USA","id":"124","num_employees":5215}',\
          '{"company_name":"Future Technology","country":"UK","id":"125","num_employees":1232}',\
          '{"company_name":"Random Corp.","country":"AU","id":"126","num_employees":531}']
        ```

        ```shell
          {"id": "124", "company_name": "Stark Industries", "num_employees": 5215,\
          "country": "US"}
          {"id": "125", "company_name": "Future Technology", "num_employees": 1232,\
          "country": "UK"}
          {"id": "126", "company_name": "Random Corp.", "num_employees": 531,\
          "country": "AU"}
        ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/documents/export</code></p>

      <h4 id="import-documents">Import documents into a collection</h4>

      <p>The documents to be imported must be formatted in a newline delimited JSON stucture.
         You can feed the output file from a Typesense export operation directly as import.</p>

      <p>Here's an example file:</p>

      {% code_block import-documents-err-response %}
      ```jsonl
      {"name": "Stark Industries", "num_employees": 5215, "country": "USA"}
      {"name": "Orbit Inc.", "num_employees": 256, "country": "UK"}
      ```
      {% endcode_block %}

      <p>You can import the above <code>documents.jsonl</code> file like this.</p>

      {% code_block import-documents %}
      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X POST --data-binary @documents.jsonl
      "http://localhost:8108/collections/companies/documents/import"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block import-documents-response %}
      ```json
          {
            "items":[
              { "success":true },
              { "success":true },
              { "success":true }
            ],
            "num_imported":3,
            "success":true
          }
      ```
      {% endcode_block %}

      <p>The response will consist of an <code>items</code> array that indicates the result of each document present in the request
      to be imported (in the same order). If the import of a single document fails, it does not affect the
        remaining documents.</p>

      <p>If there is a failure, the response item will include a corresponding error message. For example, the second
      document had an import failure in the following response:</p>

      {% code_block import-documents-err-response %}
      ```json
      {
        "items":[
          { "success":true },
          { "success":false, "error": "Bad JSON." },
          { "success":true }
        ],
        "num_imported":2,
        "success":false
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>POST ${TYPESENSE_HOST}/collections/:collection/documents/import</code></p>

      <h4 id="list-collection">List all collections</h4>

      <p>Returns a summary of all your collections. The collections are returned sorted by creation date,
        with the most recent collections appearing first.</p>

      {% code_block list-collection %}
      ```ruby
        client.collections.retrieve
      ```

      ```python
        client.collections.retrieve()
      ```

      ```javascript
        client.collections().retrieve()
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" "http://localhost:8108/collections"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block list-collection-response %}
      ```json
      {
        "collections": [
          {
            "num_documents": 1250,
            "name": "companies",
            "fields": [
              {"name": "company_name", "type": "string"},
              {"name": "num_employees", "type": "int32"},
              {"name": "country", "type": "string", "facet": true}
            ],
            "default_sorting_field": "num_employees"
          },
          {
            "num_documents": 1250,
            "name": "ceos",
            "fields": [
              {"name": "company_name", "type": "string"},
              {"name": "full_name", "type": "string"},
              {"name": "from_year", "type": "int32"}
            ],
            "default_sorting_field": "num_employees"
          }
        ]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections</code></p>

      <h4 id="drop-collection">Drop a collection</h4>

      <p>Permanently drops a collection. This action cannot be undone. For large collections, this might have an impact on read
        latencies.</p>

      {% code_block drop-collection %}
      ```ruby
        client.collections['companies'].delete
      ```

      ```python
        client.collections['companies'].delete()
      ```

      ```javascript
        client.collections('companies').delete()
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X DELETE
            "http://localhost:8108/collections/companies"
      ```

      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block drop-collection-response %}
      ```json
      {
        "name": "companies",
        "num_documents": 1250,
        "fields": [
          {"name": "company_name", "type": "string"},
          {"name": "num_employees", "type": "int32"},
          {"name": "country", "type": "string", "facet": true}
        ],
        "default_sorting_field": "num_employees"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>DELETE ${TYPESENSE_HOST}/collections/:collection</code></p>

      <h3 id="curation">Curation</h3>

      <p>While Typesense makes it really easy and intuitive to deliver great search results, sometimes you might
        want to promote certain documents over others. Or, you might want to exclude certain documents from a
        query's result set.</p>

      <p>Using overrides, you can include or exclude specific documents for a given query.</p>

      <h4 id="create-update-override">Create or update an override</h4>

      <p>In the following example, we are overriding the search results by placing the documents with ids <code>422</code>
        and <code>54</code> in the first and second positions respectively via the <code>includes</code> condition.
        Additionally, we're ensuring that the document with id <code>287</code> is not returned at all
        via the <code>excludes</code> condition. You need to specify only one of <code>exclude</code> or
        <code>include</code>.</p>

      <p>Note how we are applying these overrides to an <code>exact</code> match of the query <code>apple</code>.
        Instead, if we want to match all queries that contained the word <code>apple</code>, we will use
        the <code>contains</code> match instead.</p>

      {% code_block create-update-override %}
      ```ruby
      override = {
        "rule" => {
          "query" => "apple",
          "match" => "exact"
        },
        "includes" => [
          {"id" => "422", "position" => 1},
          {"id" => "54", "position" => 2}
        ],
        "excludes" => [
          {"id" => "287"}
        ]
      }

      # Creates/updates an override called `customize-apple` in the `companies` collection
      client.collections['companies'].overrides.upsert('customize-apple', override)
      ```

      ```python
      override = {
        "rule": {
          "query": "apple",
          "match": "exact"
        },
        "includes": [
          {"id": "422", "position": 1},
          {"id": "54", "position": 2}
        ],
        "excludes": [
          {"id": "287"}
        ]
      }

      # Creates/updates an override called `customize-apple` in the `companies` collection
      client.collections['companies'].overrides.upsert('customize-apple', override)
      ```

      ```javascript
      override = {
        "rule": {
          "query": "apple",
          "match": "exact"
        },
        "includes": [
          {"id": "422", "position": 1},
          {"id": "54", "position": 2}
        ],
        "excludes": [
          {"id": "287"}
        ]
      }

      // Creates/updates an override called `customize-apple` in the `companies` collection
      client.collections('companies').overrides().upsert('customize-apple', override)
      ```

      ```shell
      curl "http://localhost:8108/collections/companies/overrides/customize-apple" -X PUT \
      -H "Content-Type: application/json" \
      -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
        "rule": {
          "query": "apple",
          "match": "exact"
        },
        "includes": [
          {"id": "422", "position": 1},
          {"id": "54", "position": 2}
        ],
        "excludes": [
          {"id": "287"}
        ]
      }'
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "id": "customize-apple",
        "excludes": [
          {
            "id": "287"
          }
        ],
        "includes": [
          {
            "id": "422",
            "position": 1
          },
          {
            "id": "54",
            "position": 2
          }
        ],
        "rule": {
          "match": "exact",
          "query": "apple"
        }
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>PUT ${TYPESENSE_HOST}/collections/:collection/overrides/:id</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>excludes</td>
          <td>no</td>
          <td>List of document <code>id</code>s that should be excluded from the search results.</td>
        </tr>
        <tr>
          <td>includes</td>
          <td>no</td>
          <td>List of document <code>id</code>s that should be included in the search results with their
            corresponding <code>position</code>s.</td>
        </tr>
        <tr>
          <td>rule.query</td>
          <td>yes</td>
          <td>Indicates what search queries should be overridden.</td>
        </tr>
        <tr>
          <td>rule.match</td>
          <td>yes</td>
          <td>Indicates whether the match on the query term should be <code>exact</code> or <code>contains</code>.</td>
        </tr>
      </table>

      <hr />

      <h4 id="list-overrides">List all overrides</h4>

      <p>Listing all overrides associated with a given collection.</p>

      {% code_block list-overrides %}
      ```ruby
      client.collections['companies'].overrides.retrieve
      ```

      ```python
      client.collections['companies'].overrides.retrieve()
      ```

      ```javascript
      client.collections('companies').overrides().retrieve
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
      "http://localhost:8108/collections/companies/overrides"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "overrides":[
          {
            "id":"customize-apple",
            "excludes":[
              {
                "id":"287"
              }
            ],
            "includes":[
              {
                "id":"422",
                "position":1
              },
              {
                "id":"54",
                "position":2
              }
            ],
            "rule":{
              "match":"exact",
              "query":"apple"
            }
          }
        ]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/overrides</code></p>

      <hr />

      <h4 id="delete-override">Delete an override</h4>

      <p>Deleting an override associated with a collection.</p>

      {% code_block delete-override %}
      ```ruby
      client.collections['companies'].overrides['customize-apple'].delete
      ```

      ```python
      client.collections['companies'].overrides['customize-apple'].delete()
      ```

      ```javascript
      client.collections('companies').overrides('customize-apple').delete()
      ```

      ```shell
      curl "http://localhost:8108/collections/companies/overrides/customize-apple" -X DELETE \
      -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block delete-alias-response %}
      ```json
      {
        "id": "customize-apple"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>DELETE ${TYPESENSE_HOST}/collections/:collection/overrides/:id</code></p>
      <hr />

      <h3 id="aliases">Collection Alias</h3>

      <p>An alias is a virtual collection name that points to a real collection. If you're familiar with
        symbolic links on Linux, it's very similar to that. </p>

      <p>Aliases are useful when you want to reindex your
        data in the background on a new collection and switch your application to it without any changes
        to your code. Let's take an example.</p>

      <p>Let's say we have a collection called <code>companies_june10</code> and an alias
         called <code>companies</code> pointing to that collection.</p>

      <p><code>collection ---> companies_june10</code></p>

      <p>On the next day (June 11), we will create a new collection called <code>companies_june11</code>
        and start indexing the documents in the background into this collection. When we are done indexing,
        if we updated the <code>companies</code> alias to point to this new collection,
        your application would immediately start querying against the freshly indexed collection.</p>

      <p><code>collection ---> companies_june11</code></p>

      <p>Convenient isn't it? Let's now look at how we can create, update and manage aliases.</p>

      <hr />

      <h4 id="create-update-alias">Create or Update an alias</h4>

      {% code_block create-update-alias %}
      ```ruby
          aliased_collection = {
            'collection_name' => 'companies_june11'
          }

          # Creates/updates an alias called `companies` to the `companies_june11` collection
          client.aliases.upsert('companies', aliased_collection)
      ```

      ```python
          aliased_collection = {
            'collection_name': 'companies_june11'
          }

          # Creates/updates an alias called `companies` to the `companies_june11` collection
          client.aliases.upsert('companies', aliased_collection)
      ```

      ```javascript
        aliased_collection = {
          'collection_name': 'companies_june11'
        }

        // Creates/updates an alias called `companies` to the `companies_june11` collection
        client.aliases.upsert('companies', aliased_collection)
      ```

      ```shell
        curl "http://localhost:8108/aliases/companies" -X PUT \
            -H "Content-Type: application/json" \
            -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
                "collection_name": "companies_june11"
            }'
        ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "name": "companies",
        "collection_name": "companies_june11",
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>PUT ${TYPESENSE_HOST}/aliases/:alias</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>collection_name</td>
          <td>yes</td>
          <td>Name of the collection you wish to map the alias to.</td>
        </tr>
      </table>

      <hr />

      <h4 id="retrieve-alias">Retrieve an alias</h4>

      <p>We can find out which collection an alias points to by fetching it.</p>

      {% code_block retrieve-alias %}
      ```ruby
        client.aliases['companies'].retrieve
      ```

      ```python
        client.aliases['companies'].retrieve()
      ```

      ```javascript
        client.aliases('companies').retrieve()
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
            "http://localhost:8108/aliases/companies"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
        {
          "name": "companies",
          "collection_name": "companies_june11",
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/aliases/:alias</code></p>

      <hr />

      <h4 id="list-aliases">List all aliases</h4>

      <p>List all aliases and the corresponding collections that they map to.</p>

      {% code_block list-aliases %}
      ```ruby
      client.aliases.retrieve
      ```

      ```python
      client.aliases.retrieve()
      ```

      ```javascript
      client.aliases().retrieve()
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
           "http://localhost:8108/aliases"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "aliases": [
          {
            "name": "companies",
            "collection_name": "companies_june11"
          },
          {
            "name": "employees",
            "collection_name": "employees_june11"
          }
        ]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/aliases</code></p>

      <hr />

      <h4 id="delete-alias">Delete an alias</h4>

      {% code_block delete-alias %}
      ```ruby
        client.aliases['companies'].delete
      ```

      ```python
        client.aliases['companies'].delete()
      ```

      ```javascript
        client.aliases('companies').delete()
      ```

      ```shell
      curl "http://localhost:8108/aliases/companies" -X DELETE
          -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block delete-alias-response %}
      ```json
      {
        "name": "companies",
        "collection_name": "companies_june11"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>DELETE ${TYPESENSE_HOST}/aliases/:alias</code></p>

      <h3 id="whats-new">What's new in 0.12.0</h3>

      <p>This is a major release packed with multiple new features and a few bug fixes.</p>

      <ul>
        <li><strong>[Feature]</strong> Raft-based clustering for high write+read availability. We also deprecate
          the read-only replication feature supported via the <code>--master</code> argument.</li>
        <li><strong>[Feature]</strong> Ability to Curate / Merchandize search results is now available in the
          open source version, via the Overrides feature.</li>
        <li><strong>[Feature]</strong> Ability to create Aliases for collections is now available in the open source version.</li>
        <li><strong>[Feature]</strong> Allow the maximum number of results returned to be configurable via the
          <code>max_hits</code> parameter. Previously only the top 500 results were returned.</li>
        <li><strong>[Feature]</strong> Facet search: facet values that are returned can now be filtered via the
          <code>facet_query</code> parameter. The matching facet text is also highlighted.</li>
        <li><strong>[Feature]</strong> Allow integer and float values to be facetable.</li>
        <li><strong>[Feature]</strong> Facet stats such as min/max/avg are computed for numerical facet fields.</li>
        <li><strong>[Feature]</strong> Allow fields to be marked as optional in the schema.</li>
        <li><strong>[Feature]</strong> Expose <code>typo_tokens_threshold</code> parameter: If the number of results
          found for a specific query is less than this number, Typesense will attempt to look for tokens with more
          typos until enough results are found. Previously, this was hard-coded to <code>100</code>.</li>
        <li><strong>[Feature]</strong> The underlying string similarity score is exposed as <code>_text_match</code>
          and can be used as a sorting field parameter.</li>
        <li><strong>[Security]</strong> Enforce API key authentication always for search end-point. Previously, search endpoint
        was open unless a search-only API key was explicitly defined.</li>
        <li><strong>[Bug]</strong> Ensure that float fields defined as a sorting field accepted integer values.</li>
        <li><strong>[Bug]</strong> Fixed an edge case that resulted in incomplete deletion of string array values
          when a document is deleted.</li>
        <li><strong>[Others]</strong> Adopted GPL v3 license.</li>
      </ul>

      <h3 id="errors">API errors</h3>

      <p>Typesense API uses standard HTTP response codes to indicate the success or failure of a request.</p>

      <p>Codes in the 2xx range indicate success, codes in the 4xx range indicate an error given the information provided
      (e.g. a required parameter was omitted), and codes in the 5xx range indicate an error with the Typesense service itself.
      </p>

      <table class="table table-striped">
        <tr>
          <th>Error Code</th>
          <th>Meaning</th>
        </tr>

        <tr>
          <td>400</td>
          <td>Bad Request - The request could not be understood due to malformed syntax.</td>
        </tr>

        <tr>
          <td>401</td>
          <td>Unauthorized - Your API key is wrong.</td>
        </tr>

        <tr>
          <td>404</td>
          <td>Not Found - The requested resource is not found.</td>
        </tr>

        <tr>
          <td>409</td>
          <td>Conflict - When a resource already exists.</td>
        </tr>

        <tr>
          <td>422</td>
          <td>Unprocessable Entity - Request is well-formed, but cannot be processed.</td>
        </tr>

        <tr>
          <td>503</td>
          <td>Service Unavailable - Weâ€™re temporarily offline. Please try again later.</td>
        </tr>
      </table>
  </div>

  <div class="col-md-1 row no-gutters"></div>

  <div class="col-md-3 row no-gutters">
      <nav id="navbar-docs" class="navbar navbar-light navbar-text">
        <nav class="nav nav-pills flex-column sticky-top">
          <a class="nav-link" href="#introduction">Introduction</a>
          <a class="nav-link" href="#api-clients">API clients</a>
          <a class="nav-link" href="#authentication">Authentication</a>
          <a class="nav-link" href="#usage">Usage</a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#create-collection">Create a collection</a>
            <a class="nav-link ml-3 my-1" href="#index-document">Index a document</a>
            <a class="nav-link ml-3 my-1" href="#search-collection">Search a collection</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-document">Retrieve a document</a>
            <a class="nav-link ml-3 my-1" href="#delete-document">Delete a document</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-collection">Retrieve a collection</a>
            <a class="nav-link ml-3 my-1" href="#export-documents">Export documents</a>
            <a class="nav-link ml-3 my-1" href="#import-documents">Import documents</a>
            <a class="nav-link ml-3 my-1" href="#list-collection">List all collections</a>
            <a class="nav-link ml-3 my-1" href="#drop-collection">Drop a collection</a>
          </nav>
          <a class="nav-link" href="#curation">Curation / Merchandizing </a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#create-update-override">Create/Update an override</a>
            <a class="nav-link ml-3 my-1" href="#list-overrides">List all overrides</a>
            <a class="nav-link ml-3 my-1" href="#delete-override">Delete an override</a>
          </nav>
          <a class="nav-link" href="#aliases">Collection Alias</a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#create-update-alias">Create/Update an alias</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-alias">Retrieve an alias</a>
            <a class="nav-link ml-3 my-1" href="#list-aliases">List all aliases</a>
            <a class="nav-link ml-3 my-1" href="#delete-alias">Delete an alias</a>
          </nav>
          <a class="nav-link" href="#whats-new">What's new in 0.12.0</a>
          <a class="nav-link" href="#errors">API errors</a>
        </nav>
      </nav>
  </div>
</div>
