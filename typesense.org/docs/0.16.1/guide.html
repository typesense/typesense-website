---
layout: page
title: Getting Started Guide
nav_label: guide
---

<div class="row no-gutters">
  <div id="doc-col" class="col-md-8">
    {% include versions.html %}

    <p>Let's begin by installing Typesense, indexing some documents and exploring the data with some search queries.</p>

    <p>For a detailed dive into the Typesense API, refer to our <a href="/api">API documentation</a>.</p>

    <h3 id="install-typesense">Installing Typesense</h3>

    <p>You can find DEB, RPM and pre-built binaries available for Linux (X86_64) and Mac OS X on our
      <a href="/downloads">downloads page</a>.</p>

    <p>We also publish official Docker images for Typesense on
      <a href="https://hub.docker.com/r/typesense/typesense/">Docker hub</a>.</p>

    <p>We also offer a managed Cloud option called Typesense Cloud <a href="https://cloud.typesense.org">here</a>.</p>

    <h5>DEB package on Ubuntu/Debian</h5>

    {% code_block deb-install %}
    ```shell
      apt install ./typesense-server-<version>-amd64.deb
    ```
    {% endcode_block %}

    <h5>RPM package on CentOS/RHEL</h5>

    {% code_block rpm-install %}
    ```shell
      yum install ./typesense-server-<version>.x86_64.rpm
      ```
    {% endcode_block %}

    <h3 id="start-typesense">Starting the Typesense server</h3>

    <p><mark><strong>NOTE:</strong> We are starting a single node here, but Typesense can also run in a clustered mode.
        See the <a href="#high-availability">high availability</a> section for more details.</mark></p>

    <h4>Installed via the package manager</h4>

    <p>If you had installed Typesense from a DEB/RPM package, the Typesense server is automatically started as a systemd
      service when installation is complete. You can check the status via:</p>

    <p><code>systemctl status typesense-server</code></p>

    <p>By default, Typesense will start on port <code>8108</code>, and the installation will generate a
       random API key, which you can view/change from the configuration file at
      <code>/etc/typesense/typesense-server.ini</code></p>

    <h4>From the pre-built binary</h4>

    <p>If you have downloaded the pre-built binary, you can start Typesense with minimal options like this:</p>

    {% code_block run-binary %}
    ```shell
      mkdir /tmp/typesense-data
      ./typesense-server --data-dir=/tmp/typesense-data --api-key=$TYPESENSE_API_KEY
    ```
    {% endcode_block %}

    <h4>From the docker image</h4>

    <p>If you want to use Docker, you can run Typesense like this:</p>

    {% code_block run-docker %}
    ```shell
      mkdir /tmp/typesense-data
      docker run -p 8108:8108 -v/tmp/typesense-data:/data typesense/typesense:{{ site.versions[0] }} \
        --data-dir /data --api-key=$TYPESENSE_API_KEY
    ```
    {% endcode_block %}

    <p>You can use the <code>/health</code> API end-point to verify that the server is ready to accept requests.</p>

    {% code_block run-docker %}
    ```shell
      curl http://localhost:8108/health
      {"ok":true}
    ```
    {% endcode_block %}

    <h4 id="typesense-arguments">Server arguments</h4>

    <table class="table table-striped">
      <tr>
        <th>Parameter</th>
        <th>Required</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>config</td>
        <td>false</td>
        <td>
          Path to the configuration file. If you use this argument, you can define
          all of the other command line arguments in a configuration file. See the "Configuring Typesense" section
          for more details.
        </td>
      </tr>
      <tr>
        <td>api-key</td>
        <td>true</td>
        <td>
          <p>A bootstrap admin API key that allows all operations. Be sure to create additional keys with specific
            ACLs using the <a href="/docs/{{ site.versions[0] }}/api#api-keys">key management API</a>.</p>
          <p><strong>NOTE: </strong>Don't expose this admin API key to your browser JS client: use the key management API
            to create <a href="/docs/{{ site.versions[0] }}/api#api-keys">search-only</a> or
            <a href="/docs/{{ site.versions[0] }}/api#generate-scoped-search-key">scoped API keys</a>.</p>
        </td>
      </tr>
      <tr>
        <td>data-dir</td>
        <td>true</td>
        <td>Path to the directory where data will be stored on disk.</td>
      </tr>
      <tr>
        <td>api-address</td>
        <td>false</td>
        <td>
          Address to which Typesense API service binds. Default: <code>0.0.0.0</code>
        </td>
      </tr>
      <tr>
        <td>api-port</td>
        <td>false</td>
        <td>
          Port on which Typesense API service listens. Default: <code>8108</code>
        </td>
      </tr>
      <tr>
        <td>peering-address</td>
        <td>false</td>
        <td>
          Internal IP address to which Typesense peering service binds. If this parameter is not specified,
          Typesense will attempt to use the first available internal IP.
        </td>
      </tr>
      <tr>
        <td>peering-port</td>
        <td>false</td>
        <td>
          Port on which Typesense peering service listens. Default: <code>8107</code>
        </td>
      </tr>
      <tr>
        <td>nodes</td>
        <td>false</td>
        <td>
          <p><em>Path to file</em> containing comma separated string of all nodes in the cluster.
            Each node definition should be in the following format:<br /><br />
          <code>&lt;ip_address&gt;:&lt;peering_port&gt;:&lt;api_port&gt;</code></p>
          <p>Example content of a <code>--nodes</code> file for a 3-node cluster:</p>
          <p><code>192.168.12.1:8107:8108,192.168.12.2:8107:8108,192.168.12.3:8107:8108</code></p>
        </td>
      </tr>
      <tr>
        <td>log-dir</td>
        <td>false</td>
        <td>
          By default, Typesense logs to stdout and stderr. To enable logging to a file, provide a path to a
          logging directory.
        </td>
      </tr>
      <tr>
        <td>ssl-certificate</td>
        <td>false</td>
        <td>
          Path to the SSL certificate file. You must also define <code>ssl-certificate-key</code> to enable HTTPS.
        </td>
      </tr>
      <tr>
        <td>ssl-certificate-key</td>
        <td>false</td>
        <td>
          Path to the SSL certificate key file. You must also define <code>ssl-certificate</code> to enable HTTPS.
        </td>
      </tr>
      <tr>
        <td>enable-cors</td>
        <td>false</td>
        <td>
          Allow Javascript client to access Typesense directly from the browser.
        </td>
      </tr>
      <tr>
        <td>catch-up-threshold-percentage</td>
        <td>false</td>
        <td>
          <p>The threshold at which a follower is deemed to have caught up with leader and will allow requests.
            Default: <code>95</code></p>

          <p>NOTE: This threshold is used only when the lag between the follower and leader
            is more than 1,000 operations.</p>
        </td>
      </tr>
      <tr>
        <td>snapshot-interval-seconds</td>
        <td>false</td>
        <td>
          <p>Frequency of replication log snapshots. Default: <code>3600</code></p>
          <p>NOTE: Frequent snapshotting helps in faster recovery from a cold start. However, if this value
          is too low for a large dataset, repeated snapshotting can actually slow down follower recovery.</p>
        </td>
      </tr>
    </table>

    <h3 id="configure-typesense">Configuring Typesense</h3>

    <p>As an alternative to command line arguments, you can also configure Typesense server through a
      configuration file or via environment variables.</p>

    <p>Command line arguments are given the highest priority, while environment variables are given the least priority.</p>

    <p><strong>Using a configuration file</strong></p>

    <p>Let's see how we can use a configuration file first:</p>

    {% code_block run-config-file %}
    ```shell
    ./typesense-server --config=/etc/typesense/typesense-server.ini
    ```
    {% endcode_block %}

    <p>Our Linux DEB/RPM packages install the configuration file at <code>/etc/typesense/typesense-server.ini</code>.</p>

    <p>The configuration file uses a simple <a target="_blank" href="https://en.wikipedia.org/wiki/INI_file">INI format</a>:</p>

    {% code_block run-config-file %}
    ```ini
    ; /etc/typesense/typesense-server.ini

    [server]

    api-key = Rhsdhas2asasdasj2
    data-dir = /tmp/ts
    log-dir = /tmp/logs
    api-port = 9090

    ```
    {% endcode_block %}

    <p><strong>Using environment variables</strong></p>

    <p>If you wish to use environment variables, you can do that too. The environment variables map to the command line
      arguments documented above: just use CAPS and underscores instead of hyphens, and prefix the variable names
      with <code>TYPESENSE_</code>.</p>

    <p>For example, use <code>TYPESENSE_DATA_DIR</code> for the <code>--data-dir</code> argument.</p>

    {% code_block run-config-file %}
    ```shell
    TYPESENSE_DATA_DIR=/tmp/ts TYPESENSE_API_KEY=AS3das2awQ2 ./typesense-server
    ```
    {% endcode_block %}

    <h3 id="install-client">Installing a client</h3>

    <p>At the moment, we have clients for Javascript, PHP, Python, Ruby. </p>
    <p>We recommend that you use our API client if it's available for your language. It's also easy to
    interact with Typesense through its simple, RESTful HTTP API.</p>

    {% code_block install %}
    ```javascript
    // Node.js
    npm install typesense

    // Browser
    <script src="dist/typesense.min.js"></script>
    ```

    ```php
    composer require typesense/typesense-php
    ```

    ```python
    pip install typesense
    ```

    ```ruby
    gem install typesense
    ```

    {% endcode_block %}

    <h3 id="example-application">Example application</h3>

    <p><mark><strong>NOTE:</strong> We will be using a single node in this example, but Typesense can also run in a clustered mode.
        See the <a href="#high-availability">high availability</a> section for more details.</mark></p>

    <p>At this point, we are all set to start using Typesense. We will create a Typesense collection, index
      some documents in it and try searching for them.</p>

    <p>To follow along, <a href="https://dl.typesense.org/datasets/books.jsonl.tar.gz">download</a> this small dataset
      that we've put together for this walk-through.</p>

    <h4 id="init-client">Initializing the client</h4>

    <p>Let's begin by configuring the Typesense client by pointing it to the Typesense master node.</p>

    <p>Be sure to use the same API key that you used to start the Typesense server earlier.</p>

    {% code_block init-client %}
    ```javascript
    /*
     *  Our Javascript client library works on both the server and the browser.
     *  When using the library on the browser, please be sure to use the
     *  search-only API Key rather than the master API key since the latter
     *  has write access to Typesense and you don't want to expose that.
     */
    let client = new Typesense.Client({
      'nodes': [{
        'host': 'localhost',
        'port': '8108',
        'protocol': 'http'
      }],
      'apiKey': '<API_KEY>',
      'connectionTimeoutSeconds': 2
    })
    ```

    ```php
    use Typesense\Client;

    $client = new Client(
      [
        'api_key'         => 'abcd',
        'nodes'           => [
          [
            'host'     => 'localhost',
            'port'     => '8108',
            'protocol' => 'http',
          ],
        ],
        'connection_timeout_seconds' => 2,
      ]
    );
    ```

    ```python
      import typesense

      client = typesense.Client({
        'nodes': [{
          'host': 'localhost',
          'port': '8108',
          'protocol': 'http'
        }],
        'api_key': '<API_KEY>',
        'connection_timeout_seconds': 2
      })
    ```

    ```ruby
      require 'typesense'

      client = Typesense::Client.new(
        nodes: [{
          host:     'localhost',
          port:     8108,
          protocol: 'http'
        }],
        api_key:  '<API_KEY>',
        connection_timeout_seconds: 2
      )
    ```

    ```shell
      export TYPESENSE_API_KEY='<API_KEY>'
      export TYPESENSE_MASTER='http://localhost:8108'
    ```
    {% endcode_block %}

    <p>That's it - we're now ready to start interacting with the Typesense server.</p>

    <h4 id="create-collection">Creating a "books" collection</h4>

    <p>In Typesense, a collection is a group of related documents that is roughly equivalent to a table in a relational database.
      When we create a collection, we give it a name and describe the fields that will be indexed when a document is
      added to the collection.</p>

    {% code_block create-collection %}
    ```javascript
      let booksSchema = {
        'name': 'books',
        'fields': [
          {'name': 'title', 'type': 'string' },
          {'name': 'authors', 'type': 'string[]' },
          {'name': 'image_url', 'type': 'string' },

          {'name': 'publication_year', 'type': 'int32' },
          {'name': 'ratings_count', 'type': 'int32' },
          {'name': 'average_rating', 'type': 'float' },

          {'name': 'authors_facet', 'type': 'string[]', 'facet': true },
          {'name': 'publication_year_facet', 'type': 'string', 'facet': true },
        ],
        'default_sorting_field': 'ratings_count'
      }

      client.collections().create(booksSchema)
        .then(function (data) {
          console.log(data)
        })
    ```

    ```php
    $booksSchema = [
      'name' => 'books',
      'fields' => [
        ['name' => 'title', 'type' => 'string'],
        ['name' => 'authors', 'type' => 'string[]'],
        ['name' => 'image_url', 'type' => 'string'],

        ['name' => 'publication_year', 'type' => 'int32'],
        ['name' => 'ratings_count', 'type' => 'int32'],
        ['name' => 'average_rating', 'type' => 'float'],

        ['name' => 'authors_facet', 'type' => 'string[]', 'facet' => true],
        ['name' => 'publication_year_facet', 'type' => 'string', 'facet' => true]
      ],
      'default_sorting_field' => 'ratings_count'
    ]

    $client->collections->create($booksSchema)
    ```

    ```python
      import typesense

      books_schema = {
        'name': 'books',
        'fields': [
          {'name': 'title', 'type': 'string' },
          {'name': 'authors', 'type': 'string[]' },
          {'name': 'image_url', 'type': 'string' },

          {'name': 'publication_year', 'type': 'int32' },
          {'name': 'ratings_count', 'type': 'int32' },
          {'name': 'average_rating', 'type': 'float' },

          {'name': 'authors_facet', 'type': 'string[]', 'facet': True },
          {'name': 'publication_year_facet', 'type': 'string', 'facet': True },
        ],
        'default_sorting_field': 'ratings_count'
      }

      client.collections.create(books_schema)
    ```

    ```ruby
      require 'typesense'

      books_schema = {
        'name' => 'books',
        'fields' => [
          {'name' => 'title', 'type' => 'string' },
          {'name' => 'authors', 'type' => 'string[]' },
          {'name' => 'image_url', 'type' => 'string' },

          {'name' => 'publication_year', 'type' => 'int32' },
          {'name' => 'ratings_count', 'type' => 'int32' },
          {'name' => 'average_rating', 'type' => 'float' },

          {'name' => 'authors_facet', 'type' => 'string[]', 'facet' => true },
          {'name' => 'publication_year_facet', 'type' => 'string', 'facet' => true }
        ],
        'default_sorting_field' => 'ratings_count'
      }

      client.collections.create(books_schema)
    ```

    ```shell
      curl "http://localhost:8108/collections" -X POST -H "Content-Type: application/json" \
            -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
              "name": "books",
              "fields": [
                {"name": "title", "type": "string" },
                {"name": "authors", "type": "string[]" },
                {"name": "image_url", "type": "string" },

                {"name": "publication_year", "type": "int32" },
                {"name": "ratings_count", "type": "int32" },
                {"name": "average_rating", "type": "float" },

                {"name": "authors_facet", "type": "string[]", "facet": true },
                {"name": "publication_year_facet", "type": "string", "facet": true }
              ],
              "default_sorting_field": "ratings_count"
            }'
    ```
    {% endcode_block %}

    <p>For each field, we define its <code>name</code>, <code>type</code> and whether it's a <code>facet</code> field.
    A facet field allows us to cluster the search results into categories and let us drill into each of those categories.
    We will be seeing faceted results in action at the end of this guide.</p>

    <p>We also define a <code>default_sorting_field</code> that determines how the results must be sorted when no
    <code>sort_by</code> clause is provided. In this case, books that have more ratings will be ranked higher.</p>

    <h4 id="index-documents">Adding books to the collection</h4>

    <p>We're now ready to index some books into the collection we just created.</p>

    {% code_block index-documents %}
    ```javascript
      var fs = require('fs');
      var readline = require('readline');

      readline.createInterface({
          input: fs.createReadStream('/tmp/books.jsonl'),
          terminal: false
      }).on('line', function(line) {
         let bookDocument = JSON.parse(line);
         client.collections('books').documents().create(bookDocument)
      });
    ```
    ```php
    $booksData = file_get_contents('/tmp/books.jsonl')
    $booksStrs = explode($booksData, '\n')

    foreach($booksStrs as $bookStr) {
      $book = json_decode($bookStr);
      $client->collections['books']->documents->create($book)
    }
    ```
    ```python
      import json
      import typesense

      with open('/tmp/books.jsonl') as infile:
        for json_line in infile:
          book_document = json.loads(json_line)
          client.collections['books'].documents.create(book_document)
    ```
    ```ruby
      require 'rubygems'
      require 'json'
      require 'typesense'

      File.readlines('/tmp/books.jsonl').each do |json_line|
        book_document = JSON.parse(json_line)
        client.collections['books'].documents.create(book_document)
      end
    ```
    ```shell
        #!/bin/bash
        input="/tmp/books.jsonl"
        while IFS= read -r line
        do
          curl "$TYPESENSE_MASTER/collections/books/documents" -X POST \
          -H "Content-Type: application/json" \
          -H "X-TYPESENSE-API-KEY: $TYPESENSE_API_KEY" \
          -d "$line"
        done < "$input"
    ```
    {% endcode_block %}

    <h4 id="search-collection">Searching for books</h4>

    <p>We will start with a really simple search query - let's search for <code>harry potter</code> and ask Typesense
    to rank books that have more ratings higher in the results.</p>

    {% code_block search-collection-1 %}

    ```javascript
      let searchParameters = {
        'q'         : 'harry',
        'query_by'  : 'title',
        'sort_by'   : 'ratings_count:desc'
      }

      client.collections('books')
        .documents()
        .search(searchParameters)
        .then(function (searchResults) {
          console.log(searchResults)
        })
    ```

    ```php
      $searchParameters = [
        'q'         => 'harry potter',
        'query_by'  => 'title',
        'sort_by'   => 'ratings_count:desc'
      ]

      $client->collections['books']->documents->search($searchParameters)
    ```

    ```python
      search_parameters = {
        'q'         : 'harry',
        'query_by'  : 'title',
        'sort_by'   : 'ratings_count:desc'
      }

      client.collections['books'].documents.search(search_parameters)
    ```

    ```ruby
      search_parameters = {
        'q'         => 'harry potter',
        'query_by'  => 'title',
        'sort_by'   => 'ratings_count:desc'
      }

      client.collections['books'].documents.search(search_parameters)
    ```

    ```shell
      curl -H "X-TYPESENSE-API-KEY: $TYPESENSE_API_KEY" \
      "$TYPESENSE_MASTER/collections/books/documents/search\
      ?q=harry+potter&query_by=title&sort_by=ratings_count:desc"
    ```
    {% endcode_block %}

    <h5>Sample response</h5>

    {% code_block search-collection-1-response %}
      ```json
      {
        "facet_counts": [],
        "found": 62,
        "hits": [
          {
            "highlights": [
              {
                "field": "title",
                "snippet": "<mark>Harry</mark> <mark>Potter</mark> and the Philosopher's Stone"
              }
            ],
            "document": {
              "authors": [
                "J.K. Rowling", "Mary GrandPr√©"
              ],
              "authors_facet": [
                "J.K. Rowling", "Mary GrandPr√©"
              ],
              "average_rating": 4.44,
              "id": "2",
              "image_url": "https://images.gr-assets.com/books/1474154022m/3.jpg",
              "publication_year": 1997,
              "publication_year_facet": "1997",
              "ratings_count": 4602479,
              "title": "Harry Potter and the Philosopher's Stone"
            }
          },
          ...
        ]
      }
      ```
    {% endcode_block %}

    <p>In addition to returning the matching documents, Typesense also highlights where the query terms appear
      in a document via the <code>highlight</code> property.</p>

    <p>Want to actually see newest <code>harry potter</code> books returned first? No problem, we can change the
      <code>sort_by</code> clause to <code>publication_year:desc</code>:</p>

    {% code_block search-collection-2 %}

    ```javascript
      let searchParameters = {
        'q'         : 'harry',
        'query_by'  : 'title',
        'sort_by'   : 'publication_year:desc'
      }

      client.collections('books')
        .documents()
        .search(searchParameters)
        .then(function (searchResults) {
          console.log(searchResults)
        })
    ```

    ```php
      $searchParameters = [
        'q'         => 'harry potter',
        'query_by'  => 'title',
        'sort_by'   => 'publication_year:desc'
      ]

      $client->collections['books']->documents->search($searchParameters)
    ```

    ```python
      search_parameters = {
        'q'         : 'harry',
        'query_by'  : 'title',
        'sort_by'   : 'publication_year:desc'
      }

      client.collections['books'].documents.search(search_parameters)
    ```

    ```ruby
      search_parameters = {
        'q'         => 'harry potter',
        'query_by'  => 'title',
        'sort_by'   => 'publication_year:desc'
      }

      client.collections['books'].documents.search(search_parameters)
    ```

    ```shell
      curl -H "X-TYPESENSE-API-KEY: $TYPESENSE_API_KEY" \
      "$TYPESENSE_MASTER/collections/books/documents/search\
      ?q=harry+potter&query_by=title&sort_by=publication_year:desc"
    ```
    {% endcode_block %}

    <h5>Sample response</h5>

    {% code_block search-collection-2-response %}
      ```json
      {
        "facet_counts": [],
        "found": 62,
        "hits": [
        {
          "highlights": [
            {
              "field": "title",
              "snippet": "<mark>Harry</mark> <mark>Potter</mark> and the Cursed Child..."
            }
          ],
          "document": {
            "authors": [
              "John Tiffany", "Jack Thorne", "J.K. Rowling"
            ],
            "authors_facet": [
              "John Tiffany", "Jack Thorne", "J.K. Rowling"
            ],
            "average_rating": 3.75,
            "id": "279",
            "image_url": "https://images.gr-assets.com/books/1470082995m/29056083.jpg",
            "publication_year": 2016,
            "publication_year_facet": "2016",
            "ratings_count": 270603,
            "title": "Harry Potter and the Cursed Child, Parts One and Two"
          }
        },
        ...
        ]
      }
      ```
    {% endcode_block %}

    <h4>Filtering results</h4>

    <p>Now, let's tweak our query to only fetch books that are published before the year <code>1998</code>.
       To do that, we just have to add a <code>filter_by</code> clause to our query:
    </p>

    {% code_block search-collection-3 %}

    ```javascript
      let searchParameters = {
        'q'         : 'harry',
        'query_by'  : 'title',
        'filter_by' : 'publication_year:<1998',
        'sort_by'   : 'publication_year:desc'
      }

      client.collections('books')
        .documents()
        .search(searchParameters)
        .then(function (searchResults) {
          console.log(searchResults)
        })
    ```

    ```php
      $searchParameters = [
        'q'         => 'harry potter',
        'query_by'  => 'title',
        'filter_by' => 'publication_year:<1998',
        'sort_by'   => 'publication_year:desc'
      ]

      $client->collections['books']->documents->search($searchParameters)
    ```

    ```python
      search_parameters = {
        'q'         : 'harry',
        'query_by'  : 'title',
        'filter_by' : 'publication_year:<1998',
        'sort_by'   : 'publication_year:desc'
      }

      client.collections['books'].documents.search(search_parameters)
    ```

    ```ruby
      search_parameters = {
        'q'         => 'harry potter',
        'query_by'  => 'title',
        'filter_by' => 'publication_year:<1998',
        'sort_by'   => 'publication_year:desc'
      }

      client.collections['books'].documents.search(search_parameters)
    ```

    ```shell
      curl -H "X-TYPESENSE-API-KEY: $TYPESENSE_API_KEY" \
      "$TYPESENSE_MASTER/collections/books/documents/search\
      ?q=harry+potter&query_by=title&sort_by=publication_year:desc\
      &filter_by=publication_year:<1998"
    ```
    {% endcode_block %}

    <h5>Sample response</h5>

    {% code_block search-collection-3-response %}
      ```json
      {
        "facet_counts": [],
        "found": 24,
        "hits": [
          {
            "highlights": {
              "title": {
                "field": "title",
                "snippet": "<mark>Harry</mark> <mark>Potter</mark> and the Philosopher's Stone"
              }
            },
            "document": {
              "authors": [
                  "J.K. Rowling", "Mary GrandPr√©"
              ],
              "authors_facet": [
                  "J.K. Rowling", "Mary GrandPr√©"
              ],
              "average_rating": 4.44,
              "id": "2",
              "image_url": "https://images.gr-assets.com/books/1474154022m/3.jpg",
              "publication_year": 1997,
              "publication_year_facet": "1997",
              "ratings_count": 4602479,
              "title": "Harry Potter and the Philosopher's Stone"
            }
          },
          ...
        ]
      }
      ```
    {% endcode_block %}

    <h4>Faceting</h4>

    <p>Let's facet the search results by the authors field to see how that works.
      Let's also use this example to see how Typesense handles typographic errors.
      Let's search for <code>experyment</code> (notice the typo!). </p>

    {% code_block search-collection-4 %}

    ```javascript
      let searchParameters = {
        'q'         : 'experyment',
        'query_by'  : 'title',
        'facet_by' : 'authors_facet',
        'sort_by'   : 'average_rating:desc'
      }

      client.collections('books')
        .documents()
        .search(searchParameters)
        .then(function (searchResults) {
          console.log(searchResults)
        })
    ```

    ```php
      $searchParameters = [
        'q'         => 'experyment',
        'query_by'  => 'title',
        'facet_by'  => 'authors_facet',
        'sort_by'   => 'average_rating:desc'
      ]

      $client->collections['books']->documents->search($searchParameters)
    ```

    ```python
      search_parameters = {
        'q'         : 'experyment',
        'query_by'  : 'title',
        'facet_by' : 'authors_facet',
        'sort_by'   : 'average_rating:desc'
      }

      client.collections['books'].documents.search(search_parameters)
    ```

    ```ruby
      search_parameters = {
        'q'         => 'experyment',
        'query_by'  => 'title',
        'facet_by'  => 'authors_facet',
        'sort_by'   => 'average_rating:desc'
      }

      client.collections['books'].documents.search(search_parameters)
    ```

    ```shell
      curl -H "X-TYPESENSE-API-KEY: $TYPESENSE_API_KEY" \
      "$TYPESENSE_MASTER/collections/books/documents/search\
      ?q=experyment&query_by=title&sort_by=average_rating:desc\
      &facet_by=authors_facet"
    ```
    {% endcode_block %}

    <p>As we can see in the result below, Typesense handled the typographic error gracefully and fetched the results
      correctly. The <code>facet_by</code> clause also gives us a neat break-down of the number of books written
    by each author in the returned search results.</p>

    <h5>Sample response</h5>

    {% code_block search-collection-4-response %}
      ```json
      {
        "facet_counts": [
          {
            "field_name": "authors_facet",
            "counts": [
                {
                    "count": 2,
                    "value": " K√§the Mazur"
                },
                {
                    "count": 2,
                    "value": "Gretchen Rubin"
                },
                {
                    "count": 2,
                    "value": "James Patterson"
                },
                {
                    "count": 2,
                    "value": "Mahatma Gandhi"
                }
            ]
          }
        ],
        "found": 3,
        "hits": [
          {
            "_highlight": {
              "title": "The Angel <mark>Experiment</mark>"
            },
            "document": {
              "authors": [
                  "James Patterson"
              ],
              "authors_facet": [
                  "James Patterson"
              ],
              "average_rating": 4.08,
              "id": "569",
              "image_url": "https://images.gr-assets.com/books/1339277875m/13152.jpg",
              "publication_year": 2005,
              "publication_year_facet": "2005",
              "ratings_count": 172302,
              "title": "The Angel Experiment"
            }
          },
          ...
        ]
      }
      ```
    {% endcode_block %}

    <p>We've come to the end of our little walk-through. For a detailed dive into Typesense,
      refer to our <a href="/api">API documentation</a>.</p>

    <h3 id="search-ui">Building Search UIs</h3>

    <p>You can use the open source <a href="https://github.com/algolia/instantsearch.js">InstantSearch.js</a> library, along with our <a href="https://github.com/typesense/typesense-instantsearch-adapter">Typesense-InstantSearch-Adapter</a> to build a plug-and-play full-featured search interface, with just a few lines of code.</p>

    <p>
      Let's start with a starter template:

      {% code_block npx-create-instantsearch-app %}
        ```shell
          $ npx create-instantsearch-app typesense-instantsearch-demo

          Creating a new InstantSearch app in typesense-instantsearch-demo.

          ? InstantSearch template InstantSearch.js
          ? InstantSearch.js version 4.5.0
          ? Application ID typesense
          ? Search API key typesense_search_only_api_key
          ? Index name books
          ? Attributes to display
            Used to generate the default result template

          üì¶  Installing dependencies...

          yarn install v1.22.0
          info No lockfile found.
          [1/4] üîç  Resolving packages...
          [2/4] üöö  Fetching packages...
          [3/4] üîó  Linking dependencies...
          [4/4] üî®  Building fresh packages...
          success Saved lockfile.
          ‚ú®  Done in 24.73s.

          üéâ  Created typesense-instantsearch-demo at typesense-instantsearch-demo.

          Begin by typing:

            cd typesense-instantsearch-demo
            yarn start

          ‚ö°Ô∏è  Start building something awesome!
        ```
      {% endcode_block %}

      A couple of setup pointers for the <code>npx create-instantsearch-app</code> command above:

      <ul>
        <li>InstantSearch template: you can pick any one of the web libraries we support: InstantSearch.js, React, Vue or Angular.</li>
        <li>InstantSearch.js version: you can leave it at the default</li>
        <li>Application ID: can be any string - we'll be replacing this later in the guide</li>
        <li>Search API key: can be any string - we'll be replacing this later in the guide with your Typesense Search-only API Key</li>
        <li>Index name: the name of your collection in Typesense</li>
        <li>Attributes to display: leave it as (none)</li>
      </ul>

      Let's now install the Typesense InstantSearch adapter, to be able to use InstantSearch with a Typesense backend:


      {% code_block npm-install-typesense-instantsearch-adapter %}
        ```shell
          $ npm install --save typesense-instantsearch-adapter
        ```
      {% endcode_block %}

      To get InstantSearch.js to use the Typesense adapter, open <code>src/app.js</code> and
      edit how InstantSearch is initialized, from this:

      {% code_block instantsearch-init-algolia %}
        ```javascript
          const searchClient = algoliasearch('typesense', 'typesense_search_only_api_key');

          const search = instantsearch({
            indexName: 'books',
            searchClient,
          });
        ```
      {% endcode_block %}

      to this:

      {% code_block instantsearch-init-typesense %}
        ```javascript
          import TypesenseInstantSearchAdapter from "typesense-instantsearch-adapter";

          const typesenseInstantsearchAdapter = new TypesenseInstantSearchAdapter({
            server: {
              apiKey: "abcd", // Be sure to use the search-only-api-key
              nodes: [
                {
                  host: "localhost",
                  port: "8108",
                  protocol: "http"
                }
              ]
            },
            // The following parameters are directly passed to Typesense's search API endpoint.
            //  So you can pass any parameters supported by the search endpoint below.
            //  queryBy is required.
            additionalSearchParameters: {
              queryBy: "title,authors"
            }
          });
          const searchClient = typesenseInstantsearchAdapter.searchClient;

          const search = instantsearch({
            searchClient,
            indexName: "books"
          });
        ```
      {% endcode_block %}

      <p>We're essentially creating a <code>searchClient</code> with the adapter and passing it to <code>instantsearch</code> when initializing it.</p>

      <p>Now, you can use any of the widgets supported by InstantSearch to build a search interface.
        In this walkthrough, we'll add a search box, along with results:</p>

  <div class="tab-content">
  {% highlight javascript %}

  search.addWidgets([
    instantsearch.widgets.searchBox({
      container: '#searchbox',
    }),
    instantsearch.widgets.hits({
      container: '#hits',
      templates: {
        item: `
          <div>
            <img src="{{image_url}}" align="left" alt="{{name}}" />
            <div class="hit-name">
              {% raw %}{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}{% endraw %}
            </div>
            <div class="hit-description">
              {% raw %}{{#helpers.highlight}}{ "attribute": "authors" }{{/helpers.highlight}}{% endraw %}
            </div>
            <div class="hit-price">\${{publication_year}}</div>
            <div class="hit-rating">Rating: {{average_rating}}</div>
          </div>
        `,
      },
    }),
    instantsearch.widgets.pagination({
      container: '#pagination',
    }),
  ]);

  search.start();
  {% endhighlight %}
  </div>

    <p>Now run <code>npm start</code> to start the dev server and view the app.
      You should now have a fully-functioning instant search interface with a search box, results that
      update as you type and pagination.
    </p>

    <h3 id="typesense-instantsearch-demo">Demo App</h3>
    <p>
      Here's a repo with a working version of the app, following the instructions above: <a href="https://github.com/typesense/typesense-instantsearch-demo">https://github.com/typesense/typesense-instantsearch-demo</a>.

      The repo also contains quick commands to start a local Typesense server (<code>npm run typesenseServer</code>) and index the books collection used in this example (<code>npm run populateTypesenseIndex</code>).
    </p>
    <p>
      InstantSearch.js also has <a href="https://github.com/algolia/react-instantsearch">React</a>, <a href="https://github.com/algolia/vue-instantsearch">Vue</a>, <a href="https://github.com/algolia/angular-instantsearch">Angular</a> cousins.
      The Typesense InstantSearch adapter is also compatible with them. Similar to the above, you only need to swap the <code>searchClient</code> to the one provided by Typesense adapter. The rest of the instructions found in each of these repos work without additional changes.
    </p>

    <h3 id="ranking-relevance">Ranking and relevance</h3>

    <p>Typesense ranks search results using a simple tie-breaking sorting algorithm that can rely on one or more of:</p>

    <ol>
      <li>Text match score, exposed as a special <code>_text_match</code> field.</li>
      <li>User-defined indexed numerical fields.</li>
    </ol>

    <h5>Text match score</h5>

    <p>The text match score is computed based on the following metrics:</p>

    <ol>
        <li><strong>Frequency:</strong> Number of tokens overlapping between the search query and a text field.
        Documents that have more overlapping tokens will be ranked above those with lesser overlapping tokens.</li>
        <li><strong>Edit distance:</strong> If a given token in the query is not found, we look at tokens
          that are within an edit distance of <code>num_typos</code> characters from the query tokens. Documents
          that contain the tokens in the query exactly are ranked higher than those containing tokens with
          larger edit distances.</li>
        <li><strong>Proximity:</strong> Whether the query tokens appear verbatim or interspersed with other tokens
          in the field. Documents in which the query tokens appear right next to each other will be ranked
          above documents where the query tokens exist but are far apart in a text field.</li>
        <li><strong>Ordering of <code>query_by</code> fields:</strong> A document that matches on a field earlier in the
          list of <code>query_by</code> fields is considered more relevant than a document matched on a field later
          in the list. </li>
    </ol>

    <p>Based on the above metrics, Typesense calculates a <code>_text_match</code> score for ranking the documents on
      text relevance.</p>

    <p>However, there will be cases when many documents contain the <em>exact tokens</em> in a search query. In such a case,
      their <code>_text_match</code> will also be the same. That's when user-defined indexed numerical fields can be
      used to break the tie. You can specify up to two such numerical fields.</p>

    <p>For example, let's say that we're searching for books with a query like <code>short story</code>.
      If there are multiple books containing these exact words, then all those documents would have the same
      text match score.</p>

    <p>To break the tie, we could specify up to two additional <code>sort_by</code> fields. For instance, we could say:</p>

    <p><code>sort_by=_text_match:desc,average_rating:desc,publication_year:desc</code></p>

    <p>This would sort the results in the following manner:</p>

    <ol>
      <li>All matching records are sorted by their text match score.</li>
      <li>If any two document share the same text match score, sort them by average rating.</li>
      <li>If there is still a tie, sort them by their year of publication.</li>
    </ol>

    <h5>Default ranking order</h5>

    <p>When you don't provide a <code>sort_by</code> parameter to your search request, the documents will be ranked
      on the text match score and default sorting field values: </p>

    <p><code>sort_by=_text_match:desc,default_sorting_field:desc</code></p>

    <h5>Strict ordering of results on a numerical field</h5>

    <p>If you wish to sort the documents strictly by an indexed numerical field like <code>price</code>, you can just move
      the text match score criteria <em>after</em> the <code>price</code> field as follows:</p>

    <p><code>sort_by=price:desc,_text_match:desc</code></p>

    <h3 id="high-availability">High Availability</h3>

    <p>You can run a cluster of Typesense nodes for high availability. Typesense uses the Raft consensus algorithm to
      manage the cluster and recover from node failures.
    </p>

    <p>Since Raft requires a quorum of nodes for consensus, <em>you need to run a <strong>minimum of 3 nodes</strong> to
      tolerate a 1-node failure.</em> Running a 5-node cluster will tolerate failures of up to 2 nodes, but at the
      expense of higher write latencies.</p>

    <p>Therefore, we recommend running a 3-node Typesense cluster.</p>

    <p><strong>Configuring a Typesense cluster</strong></p>

    <p>To start a Typesense node as part of a cluster, use the <code>--nodes</code> argument to point to a file
      that contains a comma separated string of all nodes in the cluster.</p>

    <p>Each node definition should be in the following format:<br /><br />
    <code>&lt;ip_address&gt;:&lt;peering_port&gt;:&lt;api_port&gt;</code></p>

    <p>Example content of a <code>--nodes</code> file for a 3-node cluster:</p>

    {% code_block sample-nodes-file %}
    ```config
    192.168.12.1:8107:8108,192.168.12.2:8107:8108,192.168.12.3:8107:8108
    ```
    {% endcode_block %}

    <p>In the example above, the peering port (i.e. the port used for cluster operations) is <code>8107</code>
    and the API port (the actual port to which clients connect to) is <code>8108</code>.</p>

    <p><strong>Client configuration</strong></p>

    <p>Typesense clients allow you to specify one or more nodes during client initialization.</p>

    <p>Client libraries will load balance reads and writes across all nodes and will automatically strive to recover
       from transient failures through built-in retries.</p>

    <p>Here's a sample 3-node client configuration:</p>

    {% code_block authenticate %}
      ```ruby
        require 'typesense'

        client = Typesense::Client.new(
          nodes: [
            {
              host:     '192.168.0.50',
              port:     443,
              protocol: 'https'
            },
            {
              host:     '192.168.0.51',
              port:     443,
              protocol: 'https'
            },
            {
              host:     '192.168.0.52',
              port:     443,
              protocol: 'https'
            }
          ],
          api_key:  '<API_KEY>',
          connection_timeout_seconds: 2
        )
      ```

      ```python
        import typesense

        client = typesense.Client({
          'nodes': [
            {
              host:     '192.168.0.50',
              port:     443,
              protocol: 'https'
            },
            {
              host:     '192.168.0.51',
              port:     443,
              protocol: 'https'
            },
            {
              host:     '192.168.0.52',
              port:     443,
              protocol: 'https'
            }
          ],
          'api_key': '<API_KEY>',
          'connection_timeout_seconds': 2
        })
      ```

      ```javascript
        let client = new Typesense.Client({
          'nodes': [
            {
              host:     '192.168.0.50',
              port:     443,
              protocol: 'https'
            },
            {
              host:     '192.168.0.51',
              port:     443,
              protocol: 'https'
            },
            {
              host:     '192.168.0.52',
              port:     443,
              protocol: 'https'
            }
          ],
          'apiKey': '<API_KEY>',
          'connectionTimeoutSeconds': 2
        })
      ```
    {% endcode_block %}
  </div>

  <div class="col-md-1 row no-gutters"></div>

  <div class="col-md-2 row no-gutters">
    <nav id="navbar-docs" class="position-fixed navbar navbar-light">
      <nav class="nav nav-pills flex-column">
        <a class="nav-link" href="#install-typesense">Installing Typesense</a>
        <a class="nav-link" href="#start-typesense">Starting Typesense</a>
        <a class="nav-link" href="#configure-typesense">Configuring Typesense</a>
        <a class="nav-link" href="#install-client">Installing a client</a>
        <a class="nav-link" href="#example-application">Example application</a>
        <nav class="nav nav-pills flex-column">
          <a class="nav-link ml-3 my-1" href="#init-client">Initializing the client</a>
          <a class="nav-link ml-3 my-1" href="#create-collection">Creating a books collection</a>
          <a class="nav-link ml-3 my-1" href="#index-documents">Adding some books</a>
          <a class="nav-link ml-3 my-1" href="#search-collection">Searching for books</a>
        </nav>
        <a class="nav-link" href="#search-ui">Building Search UIs</a>
        <nav class="nav nav-pills flex-column">
          <a class="nav-link ml-3 my-1" href="#typesense-instantsearch-demo">Demo app</a>
        </nav>
        <a class="nav-link" href="#ranking-relevance">Ranking &amp; relevance</a>
        <a class="nav-link" href="#high-availability">High Availability</a>
      </nav>
    </nav>
  </div>
</div>

<div class="row">
  <div class="col-md-8">

  </div>
</div>
